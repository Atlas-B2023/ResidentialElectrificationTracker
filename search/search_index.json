{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#atlas-iqp-b23-residential-heating-code-documentation","title":"Atlas IQP B23 Residential Heating Code Documentation","text":"<p>Public functions are documented on the left. A video series on YouTube will be uploaded soon to assist in learning about the usage of this program.</p>"},{"location":"backend/helper/","title":"Helper","text":""},{"location":"backend/helper/#backend.helper.ASCIIColors","title":"<code>ASCIIColors</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>ASCII colors for use in printing colored text to the terminal.</p> Source code in <code>src\\backend\\helper.py</code> <pre><code>class ASCIIColors(StrEnum):\n    \"\"\"ASCII colors for use in printing colored text to the terminal.\"\"\"\n\n    GREY = \"\\x1b[38;20m\"\n    YELLOW = \"\\x1b[33;20m\"\n    RED = \"\\x1b[31;20m\"\n    BOLD_RED = \"\\x1b[31;1m\"\n    RESET = \"\\x1b[0m\"\n</code></pre>"},{"location":"backend/helper/#backend.helper.df_to_file","title":"<code>df_to_file(df)</code>","text":"<p>Write a DataFrame to a unique file.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>the DataFrame to write</p> required Source code in <code>src\\backend\\helper.py</code> <pre><code>def df_to_file(df: pl.DataFrame):\n    \"\"\"Write a DataFrame to a unique file.\n\n    Args:\n        df (pl.DataFrame): the DataFrame to write\n    \"\"\"\n    file_path = OUTPUT_DIR / f\"{time.time()}_data_frame.csv\"\n    print(f\"Dataframe saved to {file_path.resolve()}\")\n    df.write_csv(file_path, include_header=True)\n</code></pre>"},{"location":"backend/helper/#backend.helper.is_valid_zipcode","title":"<code>is_valid_zipcode(zip)</code>","text":"<p>Check if the given ZIP code is valid based on a local file.</p> <p>Parameters:</p> Name Type Description Default <code>zip</code> <code>int</code> <p>the ZIP code to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if ZIP code is valid</p> Source code in <code>src\\backend\\helper.py</code> <pre><code>def is_valid_zipcode(zip: int) -&gt; bool:\n    \"\"\"Check if the given ZIP code is valid based on a local file.\n\n    Args:\n        zip (int): the ZIP code to check\n\n    Returns:\n        bool: if ZIP code is valid\n    \"\"\"\n    if isinstance(zip, str):\n        zip = int(zip)\n    return zip in master_df[\"ZIP\"]\n</code></pre>"},{"location":"backend/helper/#backend.helper.metro_name_to_zip_code_list","title":"<code>metro_name_to_zip_code_list(msa_name)</code>","text":"<p>Return the constituent ZIP codes for the given Metropolitan Statistical Area.</p> <p>Parameters:</p> Name Type Description Default <code>msa_name</code> <code>str</code> <p>name of the Metropolitan Statistical Area</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: list of ZIP codes found. Is empty if MSA name is invalid</p> Source code in <code>src\\backend\\helper.py</code> <pre><code>def metro_name_to_zip_code_list(msa_name: str) -&gt; list[int]:\n    \"\"\"Return the constituent ZIP codes for the given Metropolitan Statistical Area.\n\n    Args:\n        msa_name (str): name of the Metropolitan Statistical Area\n\n    Returns:\n        list[int]: list of ZIP codes found. Is empty if MSA name is invalid\n    \"\"\"\n    if msa_name == \"TEST\":\n        # return [20814]  # good and small\n        # return [22067, 55424]  # nulls in sqft\n        return [20015, 20018, 20017]  # nulls in sqft and large\n\n    df = master_df.select(\"ZIP\", \"METRO_NAME\", \"LSAD\")\n\n    return (\n        df.filter(\n            (pl.col(\"METRO_NAME\").eq(msa_name))\n            &amp; (pl.col(\"LSAD\").eq(\"Metropolitan Statistical Area\"))\n        )\n        .unique()[\"ZIP\"]\n        .to_list()\n    )\n</code></pre>"},{"location":"backend/helper/#backend.helper.req_get_to_file","title":"<code>req_get_to_file(request)</code>","text":"<p>Write the contents of a request response to a unique file.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Response</code> <p>the request</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the status code of the request</p> Source code in <code>src\\backend\\helper.py</code> <pre><code>def req_get_to_file(request: requests.Response) -&gt; int:\n    \"\"\"Write the contents of a request response to a unique file.\n\n    Args:\n        request (requests.Response): the request\n\n    Returns:\n        int: the status code of the request\n    \"\"\"\n    with open(OUTPUT_DIR / f\"{time.time()}_request.html\", \"w+\", encoding=\"utf-8\") as f:\n        f.write(request.text)\n    return request.status_code\n</code></pre>"},{"location":"backend/helper/#backend.helper.state_city_to_zip_df","title":"<code>state_city_to_zip_df(state, city)</code>","text":"<p>Take in a state and city and return the ZIP code constituents of that city.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>the state</p> required <code>city</code> <code>str</code> <p>the city</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame of ZIP codes</p> Source code in <code>src\\backend\\helper.py</code> <pre><code>def state_city_to_zip_df(state: str, city: str) -&gt; pl.DataFrame:\n    \"\"\"Take in a state and city and return the ZIP code constituents of that city.\n\n    Args:\n        state (str): the state\n        city (str): the city\n\n    Returns:\n        pl.DataFrame: DataFrame of ZIP codes\n    \"\"\"\n    return (\n        pl.read_csv(\"zip_registry.csv\")\n        .filter((pl.col(\"state\") == state) &amp; (pl.col(\"city\") == city))\n        .select(\"zipcode\")\n    )\n</code></pre>"},{"location":"backend/helper/#backend.helper.state_county_to_zip_df","title":"<code>state_county_to_zip_df(state, county)</code>","text":"<p>Take in a state and county and return the ZIP code constituents of that county.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>the state</p> required <code>county</code> <code>str</code> <p>the county</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pl.DataFrame: DataFrame of ZIP codes</p> Source code in <code>src\\backend\\helper.py</code> <pre><code>def state_county_to_zip_df(state: str, county: str) -&gt; pl.DataFrame:\n    \"\"\"Take in a state and county and return the ZIP code constituents of that county.\n\n    Args:\n        state (str): the state\n        county (str): the county\n\n    Returns:\n        pl.DataFrame: DataFrame of ZIP codes\n    \"\"\"\n    return (\n        pl.read_csv(\"zip_registry.csv\")\n        .filter((pl.col(\"state\") == state) &amp; (pl.col(\"county\") == county))\n        .select(\"zipcode\")\n    )\n</code></pre>"},{"location":"backend/helper/#backend.helper.zip_to_metro","title":"<code>zip_to_metro(zip)</code>","text":"<p>Find the Metropolitan Statistical Area name for the specified ZIP code.</p> <p>Parameters:</p> Name Type Description Default <code>zip</code> <code>int</code> <p>the ZIP code to look up</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the Metropolitan name. Is empty if the ZIP code is not a part of a Metropolitan Statistical Area</p> Source code in <code>src\\backend\\helper.py</code> <pre><code>def zip_to_metro(zip: int) -&gt; str:\n    \"\"\"Find the Metropolitan Statistical Area name for the specified ZIP code.\n\n    Args:\n        zip (int): the ZIP code to look up\n\n    Returns:\n        str: the Metropolitan name. Is empty if the ZIP code is not a part of a Metropolitan Statistical Area\n    \"\"\"\n    result = master_df.filter(master_df[\"ZIP\"] == zip)[\"METRO_NAME\"]\n\n    if len(result) &gt; 0:\n        log(\"Zip has multiple codes. Only giving first one\", \"debug\")\n        return result[0]\n    else:\n        return \"\"  # should this be none?\n</code></pre>"},{"location":"backend/redfinscraper/","title":"Redfinscraper","text":""},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi","title":"<code>RedfinApi</code>","text":"<p>Scrape redfin using their stingray api. Use this class for getting and the iterating over ZIP code level data, creating an object for each new zip code.</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>class RedfinApi:\n    \"\"\"Scrape redfin using their stingray api. Use this class for getting and the iterating over ZIP code level data, creating an object for each new zip code.\"\"\"\n\n    class SoldStatus(StrEnum):\n        FOR_SALE = \"For Sale\"\n        SOLD = \"Sold\"\n\n    class HouseType(StrEnum):\n        HOUSE = \"1\"\n        CONDO = \"2\"\n        TOWNHOUSE = \"3\"\n        MULTI_FAMILY = \"4\"\n        LAND = \"5\"\n        OTHER = \"6\"\n\n    class Price(StrEnum):\n        NONE = \"None\"\n        FIFTY_THOU = \"50000\"\n        SEVENTY_FIVE_THOU = \"75000\"\n        ONE_HUN_THOU = \"100000\"\n        ONE_HUN_25_THOU = \"125000\"\n        ONE_HUN_5_THOU = \"150000\"\n        ONE_HUN_75_THOU = \"175000\"\n        TWO_HUN_THOU = \"200000\"\n        TWO_HUN_25_THOU = \"225000\"\n        TWO_HUN_5_THOU = \"250000\"\n        TWO_HUN_75_THOU = \"275000\"\n        THREE_HUN_THOU = \"300000\"\n        THREE_HUN_25_THOU = \"325000\"\n        THREE_HUN_5_THOU = \"350000\"\n        THREE_HUN_75_THOU = \"375000\"\n        FOUR_HUN_THOU = \"400000\"\n        FOUR_HUN_25_THOU = \"425000\"\n        FOUR_HUN_5_THOU = \"450000\"\n        FOUR_HUN_75_THOU = \"475000\"\n        FIVE_HUN_THOU = \"500000\"\n        FIVE_HUN_5_THOU = \"550000\"\n        SIX_HUN_THOU = \"600000\"\n        SIX_HUN_5_THOU = \"650000\"\n        SEVEN_HUN_THOU = \"700000\"\n        SEVEN_HUN_5_THOU = \"750000\"\n        EIGHT_HUN_THOU = \"800000\"\n        EIGHT_HUN_5_THOU = \"850000\"\n        NINE_HUN_THOU = \"900000\"\n        NINE_HUN_5_THOU = \"950000\"\n        ONE_MIL = \"1000000\"\n        ONE_MIL_25_THOU = \"1250000\"\n        ONE_MIL_5_THOU = \"1500000\"\n        ONE_MIL_75_THOU = \"1750000\"\n        TWO_MIL = \"2000000\"\n        TWO_MIL_25_THOU = \"2250000\"\n        TWO_MIL_5_THOU = \"2500000\"\n        TWO_MIL_75_THOU = \"2750000\"\n        THREE_MIL = \"3000000\"\n        THREE_MIL_25_THOU = \"3250000\"\n        THREE_MIL_5_THOU = \"3500000\"\n        THREE_MIL_75_THOU = \"3750000\"\n        FOUR_MIL = \"4000000\"\n        FOUR_MIL_25_THOU = \"4250000\"\n        FOUR_MIL_5_THOU = \"4500000\"\n        FOUR_MIL_75_THOU = \"4750000\"\n        FIVE_MIL = \"5000000\"\n        SIX_MIL = \"6000000\"\n        SEVEN_MIL = \"7000000\"\n        EIGHT_MIL = \"8000000\"\n        NINE_MIL = \"9000000\"\n        TEN_MIL = \"10000000\"\n\n    class SortOrder(StrEnum):\n        RECOMMENDED = \"redfin-recommended-asc\"\n        NEWEST = \"days-on-redfin-asc\"\n        MOST_RECENTLY_SOLD = \"last-sale-date-desc\"\n        LOW_HI = \"price-asc\"\n        HI_LOW = \"price-desc\"\n        SQFT = \"square-footage-desc\"\n        LOT_SIZE = \"lot-sq-ft-desc\"\n        SQFT_PRICE = \"dollars-per-sq-ft-asc\"\n\n    class SoldWithinDays(StrEnum):\n        ONE_WEEK = \"7\"\n        ONE_MONTH = \"30\"\n        THREE_MONTHS = \"90\"\n        SIX_MONTHS = \"180\"\n        ONE_YEAR = \"365\"\n        TWO_YEARS = \"730\"\n        THREE_YEARS = \"1095\"\n        FIVE_YEARS = \"1825\"\n\n    class Stories(StrEnum):\n        ONE = \"1\"\n        TWO = \"2\"\n        THREE = \"3\"\n        FOUR = \"4\"\n        FIVE = \"5\"\n        TEN = \"10\"\n        FIFTEEN = \"15\"\n        TWENTY = \"20\"\n\n    class Sqft(StrEnum):\n        NONE = \"None\"\n        SEVEN_FIFTY = \"750\"\n        THOU = \"1000\"\n        THOU_1 = \"1100\"\n        THOU_2 = \"1200\"\n        THOU_3 = \"1300\"\n        THOU_4 = \"1400\"\n        THOU_5 = \"1500\"\n        THOU_6 = \"1600\"\n        THOU_7 = \"1700\"\n        THOU_8 = \"1800\"\n        THOU_9 = \"1900\"\n        TWO_THOU = \"2000\"\n        TWO_THOU_250 = \"2250\"\n        TWO_THOU_500 = \"2500\"\n        TWO_THOU_750 = \"2750\"\n        THREE_THOU = \"3000\"\n        FOUR_THOU = \"4000\"\n        FIVE_THOU = \"5000\"\n        SEVEN_THOU_500 = \"7500\"\n        TEN_THOU = \"10000\"\n\n    def __init__(self) -&gt; None:\n        self.rf = redfin.Redfin()\n        self.DESIRED_CSV_SCHEMA = {\n            \"ADDRESS\": str,\n            \"CITY\": str,\n            \"PROPERTY TYPE\": str,\n            \"STATE OR PROVINCE\": str,\n            \"YEAR BUILT\": pl.UInt16,\n            \"ZIP OR POSTAL CODE\": pl.UInt32,\n            \"PRICE\": pl.UInt32,\n            \"SQUARE FEET\": pl.UInt32,\n            \"URL (SEE https://www.redfin.com/buy-a-home/comparative-market-analysis FOR INFO ON PRICING)\": str,\n            \"LATITUDE\": pl.Float32,\n            \"LONGITUDE\": pl.Float32,\n        }\n        self.search_params = None\n        self.column_dict = {key: False for key in CATEGORY_PATTERNS.keys()}\n\n    def set_search_params(self, zip: str, search_filters: dict[str, Any]) -&gt; None:\n        \"\"\"Set the parameters for searching by ZIP code.\n\n        Args:\n            zip (str): the ZIP code\n            search_filters (dict[str, Any]): search filters for appending to a gis-csv path\n        \"\"\"\n        try:\n            region_info = self.get_region_info_from_zipcode(zip)\n        except json.JSONDecodeError:\n            log(f\"Could not decode region info for {zip}.\", \"warn\")\n            return None\n        except HTTPError:\n            log(f\"Could not retrieve region info for {zip}.\", \"warn\")\n            return None\n\n        if search_filters.get(\"for sale sold\") == \"Sold\":\n            sort_order = self.SortOrder.MOST_RECENTLY_SOLD.value\n        else:\n            sort_order = self.SortOrder.NEWEST.value\n        # TODO make sure to fix filtering so that its not just \"single family homes\"\n\n        try:\n            market = region_info[\"payload\"][\"rootDefaults\"][\"market\"]\n            region_id = region_info[\"payload\"][\"rootDefaults\"][\"region_id\"]\n            status = str(region_info[\"payload\"][\"rootDefaults\"][\"status\"])\n        except KeyError:\n            log(\"Market, region, or status could not be identified \", \"warn\")\n            return None\n\n        self.search_params = {\n            \"al\": 1,\n            \"has_deal\": \"false\",\n            \"has_dishwasher\": \"false\",\n            \"has_laundry_facility\": \"false\",\n            \"has_laundry_hookups\": \"false\",\n            \"has_parking\": \"false\",\n            \"has_pool\": \"false\",\n            \"has_short_term_lease\": \"false\",\n            \"include_pending_homes\": \"false\",  # probably an \"include\" option\n            \"isRentals\": \"false\",\n            \"is_furnished\": \"false\",\n            \"is_income_restricted\": \"false\",\n            \"is_senior_living\": \"false\",\n            \"max_year_built\": search_filters.get(\"max year built\"),\n            \"min_year_built\": search_filters.get(\"min year built\"),\n            \"market\": market,\n            \"min_stories\": search_filters.get(\"min stories\"),\n            \"num_homes\": 350,\n            \"ord\": sort_order,\n            \"page_number\": \"1\",\n            \"pool\": \"false\",\n            \"region_id\": region_id,\n            \"region_type\": \"2\",\n            \"status\": status,\n            \"travel_with_traffic\": \"false\",\n            \"travel_within_region\": \"false\",\n            \"utilities_included\": \"false\",\n            \"v\": \"8\",\n        }\n        if search_filters.get(\"for sale sold\") == \"Sold\":\n            self.search_params[\"sold_within_days\"] = search_filters.get(\"sold within\")\n            self.search_params[\"status\"] = 9\n        else:\n            self.search_params[\"sf\"] = \"1, 2, 3, 4, 5, 6, 7\"\n            match [\n                search_filters.get(\"status coming soon\"),\n                search_filters.get(\"status active\"),\n                search_filters.get(\"status pending\"),\n            ]:\n                case [True, False, False]:\n                    status = \"8\"\n                case [False, True, False]:\n                    status = \"1\"\n                case [False, False, True]:\n                    status = \"130\"\n                case [True, True, False]:\n                    status = \"9\"\n                case [False, True, True]:\n                    status = \"139\"\n                case [True, False, True]:\n                    status = \"138\"\n                case [True, True, True]:\n                    status = \"139\"\n\n            self.search_params[\"status\"] = status\n\n        if (max_sqft := search_filters.get(\"max sqft\")) != \"None\":\n            self.search_params[\"max_sqft\"] = max_sqft\n        if (min_sqft := search_filters.get(\"min sqft\")) != \"None\":\n            self.search_params[\"min_sqft\"] = min_sqft\n\n        if (max_price := search_filters.get(\"max price\")) != \"None\":\n            self.search_params[\"max_price\"] = max_price\n        if (min_price := search_filters.get(\"min price\")) != \"None\":\n            self.search_params[\"min_price\"] = min_price\n\n        houses = \"\"  # figure out how to join into comma string\n        if search_filters.get(\"house type house\") is True:\n            houses = houses + \"1\"\n        if search_filters.get(\"house type condo\") is True:\n            houses = houses + \"2\"\n        if search_filters.get(\"house type townhouse\") is True:\n            houses = houses + \"3\"\n        if search_filters.get(\"house type mul fam\") is True:\n            houses = houses + \"4\"\n\n        self.search_params[\"uipt\"] = \",\".join(list(houses))\n\n    # redfin setup\n    def meta_request_download(self, url: str, search_params) -&gt; str:\n        \"\"\"Method for downloading objects from Redfin.\n\n        Args:\n            url (str): the Redfin URL\n\n        Returns:\n            str: the unicode text response\n        \"\"\"\n        response = requests.get(\n            self.rf.base + url, params=search_params, headers=self.rf.user_agent_header\n        )\n        log(response.request.url, \"debug\")\n        response.raise_for_status()\n        return response.text\n\n    def working_below_the_fold(self, property_id: str, listing_id: str = \"\") -&gt; Any:\n        \"\"\"A below_the_fold method that accepts a listing ID.\n        Note:\n            If you can get the listing ID, make sure to pass it to this function. You will possibly get incorrect data if you do not pass it\n\n        Args:\n            property_id (str): the property ID\n            listing_id (str): The listing ID. Defaults to False.\n\n        Returns:\n            Any: response\n        \"\"\"\n        if listing_id:\n            params = {\n                \"accessLevel\": 1,\n                \"propertyId\": property_id,\n                \"listingId\": listing_id,\n                \"pageType\": 1,\n            }\n        else:\n            params = {\n                \"accessLevel\": 1,\n                \"propertyId\": property_id,\n                \"pageType\": 1,\n            }\n        return self.rf.meta_request(\"/api/home/details/belowTheFold\", params)\n\n    def get_region_info_from_zipcode(self, zip_code: str) -&gt; Any:\n        \"\"\"Get the region ifo from a ZIP code.\n\n        Args:\n            zip_code (str): the ZIP code\n\n        Returns:\n            Any: response\n        \"\"\"\n        return self.rf.meta_request(\n            \"api/region\", {\"region_id\": zip_code, \"region_type\": 2, \"tz\": True, \"v\": 8}\n        )\n\n    def get_gis_csv(self, params: dict[str, Any]) -&gt; str:\n        \"\"\"Get the gis-csv of an area based on the contents of `params`\n\n        Args:\n            params (dict[str, Any]): the parameters\n\n        Returns:\n            str: the CSV file as a unicode string\n        \"\"\"\n        return self.meta_request_download(\"api/gis-csv\", search_params=params)\n\n    # calls stuff\n    def get_heating_info_from_super_group(self, super_group: dict) -&gt; list[str]:\n        \"\"\"Extract heating information from a super group\n\n        :\n            Must supply a probable heating group for accurate information\n\n            Format of super group in JSON:\n            {\n                types: []\n                amenityGroups: [\n                    {\n                        groupTitle: \"\"\n                        referenceName : \"\"\n                        amenityEntries : [\n                            {\n                                amenityName : \"\"\n                                referenceName: \"\"\n                                accessLevel : 1\n                                displayLevel : 1\n                                amenityValues : []\n                            },...\n                        ]\n                    }\n                ]\n                titleString: \"\"\n            }\n\n            Format of groupTitle/propertyDetailsHeader on website:\n                Interior -&gt; titleString\n                ...\n                    Heating &amp; Cooling -&gt; groupTitle\n                        Electric -&gt; no amenityName\n                        Ceiling Fan(s), Programmable Thermostat, Refrigeration -&gt; no amenityName\n                        Heating/Cooling Updated In: 2022 -&gt; amenityName = Heating/Cooling Updated In\n\n        Args:\n            super_group (dict): the super group to extract terms from\n\n        Returns:\n            list[str]: list of heating terms\n        \"\"\"\n        amenity_values = []\n        for amenity in super_group.get(\"amenityGroups\", \"\"):  #\n            if not any(\n                AMENITY_GROUP_INCLUDE_PATTERNS.findall(amenity.get(\"groupTitle\", \"\"))\n            ):\n                continue  # this is the name that is bold\n            # these are the bulleted items.\n            for amenity_entry in amenity.get(\"amenityEntries\", \"\"):\n                # if == \"\", then item is dangling (no word before colon). give the same treatment to \"utilities: ...\" as if it were ==\"\"\n                amenity_name = amenity_entry.get(\"amenityName\", \"\")\n\n                if amenity_name and not any(\n                    re.compile(\"utilit\", re.I).findall(amenity_name)\n                ):\n                    # filter the before colon. first if is to have stricter capture rule when amenity item is \"Utilities: Natural gas, heat pump, ...\"\n                    if any(\n                        AMENITY_NAME_INCLUDE_PATTERNS.findall(amenity_name)\n                    ) and not any(AMENITY_NAME_EXCLUDE_PATTERNS.findall(amenity_name)):\n                        amenity_values.extend(\n                            [\n                                value\n                                for value in amenity_entry.get(\"amenityValues\", \"\")\n                                if any(\n                                    regex.findall(value)\n                                    for regex in AFTER_COLON_FUEL_AND_APPLIANCE_INCLUDE_PATTERNS\n                                )\n                                and not any(AFTER_COLON_EXCLUDE_PATTERNS.findall(value))\n                            ]\n                        )\n                else:\n                    # filter for appliance if dangling or in utilities bullet item\n                    amenity_values.extend(\n                        [\n                            value\n                            for value in amenity_entry.get(\"amenityValues\", \"\")\n                            if any(\n                                regex.findall(value)\n                                for regex in APPLIANCE_HEATING_RELATED_PATTERNS\n                            )\n                        ]\n                    )\n        return amenity_values\n\n    def get_super_groups_from_url(self, listing_url: str) -&gt; list | None:\n        \"\"\"Get super group list from listing url.\n\n        Args:\n            listing_url (str): The path part of the listing URL. This is without the \"redfin.com\" part. Include the first forward slash\n\n        Returns:\n            list | None: List of all super groups from a Redfin Url. None if an error is encountered or if no super groups were found\n        \"\"\"\n        if \"redfin\" in listing_url:\n            listing_url = urlparse(listing_url).path\n\n        try:\n            time.sleep(random.uniform(1.2, 2.1))\n            initial_info = self.rf.initial_info(listing_url)\n        except json.JSONDecodeError:\n            log(f\"Could not get initial info for {listing_url =}\", \"warn\")\n            return None\n        try:\n            property_id = initial_info[\"payload\"][\"propertyId\"]\n        except KeyError:\n            log(\"Could not find property id\", \"critical\")\n            return None\n        try:\n            listing_id = initial_info[\"payload\"][\"listingId\"]\n        except KeyError:\n            listing_id = None\n            log(\n                \"Could not find listing id. Will try to continue. if errors in final zip csv, this might be the issue\",\n                \"warn\",\n            )\n        try:\n            time.sleep(random.uniform(1.1, 2.1))\n            if listing_id is None:\n                mls_data = self.working_below_the_fold(property_id)\n            else:\n                mls_data = self.working_below_the_fold(property_id, listing_id)\n        except json.JSONDecodeError:\n            log(f\"Could not find mls details for {listing_url = }\", \"warn\")\n            return None\n        try:\n            super_groups = mls_data[\"payload\"][\"amenitiesInfo\"][\"superGroups\"]\n        except KeyError:\n            log(f\"Could not find property details for {listing_url = }\", \"warn\")\n            return None\n        return super_groups\n\n    def get_heating_terms_dict_from_listing(\n        self, address_and_url_list: list[str]\n    ) -&gt; dict[str, bool]:\n        \"\"\"Generate a filled out dictionary based on `self.column_dict` and the contents of :meth:get_heating_info_from_super_group(address_url_list).\n\n        TODO:\n            Since addresses can be doubled and it is random which one gets chosen, just printing listing url so that we can see which one has been chosen\n\n        Args:\n            address_and_url_list (list[str]): address in the first position, and the listing URL in the second position\n\n        Returns:\n            dict[str, bool]: the filled out `self.column_dict` for the supplied address/listing URL\n        \"\"\"\n        address = address_and_url_list[0]\n        listing_url = address_and_url_list[1]\n        terms = []\n\n        super_groups = self.get_super_groups_from_url(listing_url)\n        if super_groups is None:\n            log(\n                \"No amenities found\", \"info\"\n            )  # this and \"There was no heating information for {address}\" should be made in caller?\n            return copy.deepcopy(self.column_dict)\n        for super_group in super_groups:  # dict\n            if any(\n                SUPER_GROUP_INCLUDE_PATTERNS.findall(super_group.get(\"titleString\", \"\"))\n            ):\n                terms.extend(\n                    self.get_heating_info_from_super_group(super_group)\n                )  # this will be like [gas, electricity, heat pump]\n        if len(terms) == 0:\n            log(\n                f\"There was no heating information for {urlparse(listing_url).path}\",\n                \"info\",\n            )\n            return copy.deepcopy(self.column_dict)\n\n        # categorize the correct dict and return\n        master_dict = copy.deepcopy(self.column_dict)\n        for input_string in terms:\n            log(f\"{input_string = }\", \"debug\")\n            result = {}\n            for key, pattern in CATEGORY_PATTERNS.items():\n                if bool(re.search(pattern, input_string)):\n                    result[key] = True\n                    log(f\"Pattern matched on {key, pattern = }\", \"debug\")\n                log(f\"Pattern did not match on {key, pattern = }\", \"debug\")\n            for key in result.keys():\n                master_dict[key] = result[key] | master_dict[key]\n\n        # You'll have to df.unnest this for use in a dataframe\n        log(f\"{terms = }\", \"debug\")\n        log(f\"{master_dict = }\", \"debug\")\n        log(f\"Heating amenities found for {address}.\", \"info\")\n        return master_dict\n\n    def get_gis_csv_from_zip_with_filters(\n        self,\n    ) -&gt; pl.DataFrame | None:\n        \"\"\"Clean the GIS CSV retrieved from using the `search_params` field into the desired schema.\n\n        Returns:\n            pl.DataFrame | None: returns the DataFrame of cleaned information. None if there was not information in the GIS CSV file.\n        \"\"\"\n        if self.search_params is None:\n            return\n        csv_text = self.get_gis_csv(self.search_params)\n\n        home_types: str = self.search_params.get(\"uipt\", \"\")\n        if \"1\" in home_types:\n            home_types = home_types.replace(\"1\", \"Single Family Residential\")\n        if \"2\" in home_types:\n            home_types = home_types.replace(\"2\", \"Condo/Co-op\")\n        if \"3\" in home_types:\n            home_types = home_types.replace(\"3\", \"Townhouse\")\n        if \"4\" in home_types:\n            home_types = home_types.replace(\"4\", r\"Multi-Family \\(2-4 Unit\\)\")\n\n        try:\n            df = (\n                pl.read_csv(io.StringIO(csv_text), dtypes=self.DESIRED_CSV_SCHEMA)\n                .filter(\n                    pl.col(\"PROPERTY TYPE\").str.contains(\n                        \"|\".join(home_types.split(\",\"))\n                    )\n                )\n                .select(\n                    \"ADDRESS\",\n                    \"CITY\",\n                    \"STATE OR PROVINCE\",\n                    \"YEAR BUILT\",\n                    \"ZIP OR POSTAL CODE\",\n                    \"PRICE\",\n                    \"SQUARE FEET\",\n                    \"URL (SEE https://www.redfin.com/buy-a-home/comparative-market-analysis FOR INFO ON PRICING)\",\n                    \"LATITUDE\",\n                    \"LONGITUDE\",\n                )\n            )\n            if df.height == 0:\n                log(\n                    \"CSV was empty. This can happen if local MLS rules dont allow downloads.\",\n                    \"debug\",\n                )\n                return None\n        except Exception as e:\n            log(f\"Could not read gis csv into dataframe.\\n{csv_text = }\\n{e}\", \"warn\")\n            return None\n        return df\n\n    def get_gis_csv_for_zips_in_metro_with_filters(\n        self, msa_name: str, search_filters: dict[str, Any]\n    ) -&gt; pl.DataFrame | None:\n        \"\"\"Get a DataFrame of all GIS CSVs of a Metropolitan Statistical Area.\n\n        Args:\n            msa_name (str): a Metropolitan Statistical Area\n            search_filters (dict[str, Any]): filters to search with. generate using :meth:\n\n        Returns:\n            pl.DataFrame | None: return a DataFrame of all GIS CSVs retrieved for individual ZIP codes. None if there were no CSVs\n        \"\"\"\n        log(f\"Searching {msa_name} with filters {search_filters}.\", \"log\")\n        zip_codes = metro_name_to_zip_code_list(msa_name)\n        formatted_zip_codes = [f\"{zip_code:0{5}}\" for zip_code in zip_codes]\n        log(\n            f\"Estimated search time: {len(formatted_zip_codes) * (1.75+1.5)}\",\n            \"info\",\n        )\n        list_of_csv_dfs = []\n        for zip in formatted_zip_codes:\n            time.sleep(random.uniform(1.5, 2))\n            self.set_search_params(zip, search_filters)\n            temp = self.get_gis_csv_from_zip_with_filters()\n            if temp is None:\n                log(f\"Did not find any houses in {zip}.\", \"info\")\n                continue\n            log(f\"Found data for {temp.height} houses in {zip}.\", \"info\")\n            list_of_csv_dfs.append(temp)\n\n        if len(list_of_csv_dfs) == 0:\n            return None\n        return pl.concat(list_of_csv_dfs)\n\n    def get_house_attributes_from_metro(\n        self,\n        msa_name: str,\n        search_filters: dict[str, Any],\n        use_cached_gis_csv_csv: bool = False,\n    ) -&gt; None:\n        \"\"\"Main function. Get the heating attributes of a Metropolitan Statistical Area.\n\n        TODO:\n            statistics on metropolitan\n            Log statistics about the heating outlook of a metro.\n\n        Args:\n            msa_name (str): Metropolitan Statistical Area name\n            search_filters (dict[str, Any]): search filters\n            use_cached_gis_csv_csv (bool, optional): Whether to use an already made GIS CSV DataFrame. Defaults to False.\n\n        Returns:\n            None: None if there were no houses found in the metro\n        \"\"\"\n        msa_name_file_safe = msa_name.strip().replace(\", \", \"_\").replace(\" \", \"_\")\n        metro_output_dir_path = Path(OUTPUT_DIR_PATH) / msa_name_file_safe\n\n        if use_cached_gis_csv_csv:\n            log(\"Loading csv from cache.\", \"info\")\n            try:\n                search_page_csvs_df = pl.read_csv(\n                    metro_output_dir_path / (msa_name_file_safe + \".csv\"),\n                    dtypes=self.DESIRED_CSV_SCHEMA,\n                )\n                log(\n                    f\"Loading csv from {metro_output_dir_path / (msa_name_file_safe + \".csv\")} is complete.\",\n                    \"info\",\n                )\n            except FileNotFoundError:\n                log(\n                    f\"Loading csv from {metro_output_dir_path / (msa_name_file_safe + \".csv\")} has failed, continuing with API search.\",\n                    \"info\",\n                )\n                search_page_csvs_df = self.get_gis_csv_for_zips_in_metro_with_filters(\n                    msa_name, search_filters\n                )\n        else:\n            search_page_csvs_df = self.get_gis_csv_for_zips_in_metro_with_filters(\n                msa_name, search_filters\n            )\n\n        if search_page_csvs_df is None:\n            log(f\"No houses found within {msa_name}. Try relaxing filters.\", \"info\")\n            return None\n\n        url_col_name = \"URL (SEE https://www.redfin.com/buy-a-home/comparative-market-analysis FOR INFO ON PRICING)\"\n        search_page_csvs_df = search_page_csvs_df.filter(\n            (~pl.col(url_col_name).str.contains(\"(?i)unknown\"))\n            .and_(pl.col(\"ADDRESS\").str.len_chars().gt(0))\n            .and_(pl.col(\"SQUARE FEET\").is_not_null())\n            .and_(pl.col(\"YEAR BUILT\").is_not_null())\n        )\n        # .unique(subset=[\"LATITUDE\", \"LONGITUDE\"], maintain_order=True)\n        # sometimes when there are two of the same listings you'll see the lot and the house. cant determine at this stage, so just leaving duplicates. hopefully this can be handled in viewer\n        # also somehow gets GIS-CSV for search pages that dont allow it\n\n        log(f\"Found {search_page_csvs_df.height} possible houses in {msa_name}\", \"info\")\n        os.makedirs(metro_output_dir_path, exist_ok=True)\n        log(\n            f\"Writing csv for metro to {metro_output_dir_path / (msa_name_file_safe + \".csv\")}\",\n            \"debug\",\n        )\n        search_page_csvs_df.write_csv(\n            metro_output_dir_path / (msa_name_file_safe + \".csv\")\n        )\n\n        # go through whole csv and get the house attributes for each house. then partition the dataframe by ZIP and save files\n\n        log(\"Starting lookups on listing URLS\", \"info\")\n        log(\n            f\"Unique ZIP codes: {search_page_csvs_df[\"ZIP OR POSTAL CODE\"].n_unique()}\",\n            \"info\",\n        )\n        log(\n            f\"Estimated completion time: {search_page_csvs_df.height * 3.58} seconds\",\n            \"info\",\n        )\n\n        list_of_dfs_by_zip = search_page_csvs_df.partition_by(\"ZIP OR POSTAL CODE\")\n\n        for df_of_zip in list_of_dfs_by_zip:\n            df_of_zip = (\n                df_of_zip.with_columns(\n                    pl.concat_list([pl.col(\"ADDRESS\"), pl.col(url_col_name)])\n                    .map_elements(self.get_heating_terms_dict_from_listing)\n                    .alias(\"nest\")\n                )\n                .drop(url_col_name)\n                .unnest(\"nest\")\n            )\n\n            zip = df_of_zip.select(\"ZIP OR POSTAL CODE\").item(0, 0)\n            df_of_zip.write_csv(f\"{metro_output_dir_path}{os.sep}{zip}.csv\")\n\n        # log(f\"In {msa_name}, there are {} homes with Electric fuel, {} homes with Natural Gas, {} homes with Propane, {} homes with Diesel/Heating Oil, {} homes with Wood/Pellet, {} homes with Solar Heating, {} homes with Heat Pumps, {} homes with Baseboard, {} homes with Furnace, {} homes with Boiler, {} homes with Radiator, {} homes with Radiant Floor\")\n        log(f\"Done with searching houses in {msa_name}!\", \"info\")\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_gis_csv","title":"<code>get_gis_csv(params)</code>","text":"<p>Get the gis-csv of an area based on the contents of <code>params</code></p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict[str, Any]</code> <p>the parameters</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the CSV file as a unicode string</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_gis_csv(self, params: dict[str, Any]) -&gt; str:\n    \"\"\"Get the gis-csv of an area based on the contents of `params`\n\n    Args:\n        params (dict[str, Any]): the parameters\n\n    Returns:\n        str: the CSV file as a unicode string\n    \"\"\"\n    return self.meta_request_download(\"api/gis-csv\", search_params=params)\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_gis_csv_for_zips_in_metro_with_filters","title":"<code>get_gis_csv_for_zips_in_metro_with_filters(msa_name, search_filters)</code>","text":"<p>Get a DataFrame of all GIS CSVs of a Metropolitan Statistical Area.</p> <p>Parameters:</p> Name Type Description Default <code>msa_name</code> <code>str</code> <p>a Metropolitan Statistical Area</p> required <code>search_filters</code> <code>dict[str, Any]</code> <p>filters to search with. generate using :meth:</p> required <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>pl.DataFrame | None: return a DataFrame of all GIS CSVs retrieved for individual ZIP codes. None if there were no CSVs</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_gis_csv_for_zips_in_metro_with_filters(\n    self, msa_name: str, search_filters: dict[str, Any]\n) -&gt; pl.DataFrame | None:\n    \"\"\"Get a DataFrame of all GIS CSVs of a Metropolitan Statistical Area.\n\n    Args:\n        msa_name (str): a Metropolitan Statistical Area\n        search_filters (dict[str, Any]): filters to search with. generate using :meth:\n\n    Returns:\n        pl.DataFrame | None: return a DataFrame of all GIS CSVs retrieved for individual ZIP codes. None if there were no CSVs\n    \"\"\"\n    log(f\"Searching {msa_name} with filters {search_filters}.\", \"log\")\n    zip_codes = metro_name_to_zip_code_list(msa_name)\n    formatted_zip_codes = [f\"{zip_code:0{5}}\" for zip_code in zip_codes]\n    log(\n        f\"Estimated search time: {len(formatted_zip_codes) * (1.75+1.5)}\",\n        \"info\",\n    )\n    list_of_csv_dfs = []\n    for zip in formatted_zip_codes:\n        time.sleep(random.uniform(1.5, 2))\n        self.set_search_params(zip, search_filters)\n        temp = self.get_gis_csv_from_zip_with_filters()\n        if temp is None:\n            log(f\"Did not find any houses in {zip}.\", \"info\")\n            continue\n        log(f\"Found data for {temp.height} houses in {zip}.\", \"info\")\n        list_of_csv_dfs.append(temp)\n\n    if len(list_of_csv_dfs) == 0:\n        return None\n    return pl.concat(list_of_csv_dfs)\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_gis_csv_from_zip_with_filters","title":"<code>get_gis_csv_from_zip_with_filters()</code>","text":"<p>Clean the GIS CSV retrieved from using the <code>search_params</code> field into the desired schema.</p> <p>Returns:</p> Type Description <code>DataFrame | None</code> <p>pl.DataFrame | None: returns the DataFrame of cleaned information. None if there was not information in the GIS CSV file.</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_gis_csv_from_zip_with_filters(\n    self,\n) -&gt; pl.DataFrame | None:\n    \"\"\"Clean the GIS CSV retrieved from using the `search_params` field into the desired schema.\n\n    Returns:\n        pl.DataFrame | None: returns the DataFrame of cleaned information. None if there was not information in the GIS CSV file.\n    \"\"\"\n    if self.search_params is None:\n        return\n    csv_text = self.get_gis_csv(self.search_params)\n\n    home_types: str = self.search_params.get(\"uipt\", \"\")\n    if \"1\" in home_types:\n        home_types = home_types.replace(\"1\", \"Single Family Residential\")\n    if \"2\" in home_types:\n        home_types = home_types.replace(\"2\", \"Condo/Co-op\")\n    if \"3\" in home_types:\n        home_types = home_types.replace(\"3\", \"Townhouse\")\n    if \"4\" in home_types:\n        home_types = home_types.replace(\"4\", r\"Multi-Family \\(2-4 Unit\\)\")\n\n    try:\n        df = (\n            pl.read_csv(io.StringIO(csv_text), dtypes=self.DESIRED_CSV_SCHEMA)\n            .filter(\n                pl.col(\"PROPERTY TYPE\").str.contains(\n                    \"|\".join(home_types.split(\",\"))\n                )\n            )\n            .select(\n                \"ADDRESS\",\n                \"CITY\",\n                \"STATE OR PROVINCE\",\n                \"YEAR BUILT\",\n                \"ZIP OR POSTAL CODE\",\n                \"PRICE\",\n                \"SQUARE FEET\",\n                \"URL (SEE https://www.redfin.com/buy-a-home/comparative-market-analysis FOR INFO ON PRICING)\",\n                \"LATITUDE\",\n                \"LONGITUDE\",\n            )\n        )\n        if df.height == 0:\n            log(\n                \"CSV was empty. This can happen if local MLS rules dont allow downloads.\",\n                \"debug\",\n            )\n            return None\n    except Exception as e:\n        log(f\"Could not read gis csv into dataframe.\\n{csv_text = }\\n{e}\", \"warn\")\n        return None\n    return df\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_heating_info_from_super_group","title":"<code>get_heating_info_from_super_group(super_group)</code>","text":"<p>Extract heating information from a super group</p> <p>:     Must supply a probable heating group for accurate information</p> <pre><code>Format of super group in JSON:\n{\n    types: []\n    amenityGroups: [\n        {\n            groupTitle: \"\"\n            referenceName : \"\"\n            amenityEntries : [\n                {\n                    amenityName : \"\"\n                    referenceName: \"\"\n                    accessLevel : 1\n                    displayLevel : 1\n                    amenityValues : []\n                },...\n            ]\n        }\n    ]\n    titleString: \"\"\n}\n\nFormat of groupTitle/propertyDetailsHeader on website:\n    Interior -&gt; titleString\n    ...\n        Heating &amp; Cooling -&gt; groupTitle\n            Electric -&gt; no amenityName\n            Ceiling Fan(s), Programmable Thermostat, Refrigeration -&gt; no amenityName\n            Heating/Cooling Updated In: 2022 -&gt; amenityName = Heating/Cooling Updated In\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>super_group</code> <code>dict</code> <p>the super group to extract terms from</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: list of heating terms</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_heating_info_from_super_group(self, super_group: dict) -&gt; list[str]:\n    \"\"\"Extract heating information from a super group\n\n    :\n        Must supply a probable heating group for accurate information\n\n        Format of super group in JSON:\n        {\n            types: []\n            amenityGroups: [\n                {\n                    groupTitle: \"\"\n                    referenceName : \"\"\n                    amenityEntries : [\n                        {\n                            amenityName : \"\"\n                            referenceName: \"\"\n                            accessLevel : 1\n                            displayLevel : 1\n                            amenityValues : []\n                        },...\n                    ]\n                }\n            ]\n            titleString: \"\"\n        }\n\n        Format of groupTitle/propertyDetailsHeader on website:\n            Interior -&gt; titleString\n            ...\n                Heating &amp; Cooling -&gt; groupTitle\n                    Electric -&gt; no amenityName\n                    Ceiling Fan(s), Programmable Thermostat, Refrigeration -&gt; no amenityName\n                    Heating/Cooling Updated In: 2022 -&gt; amenityName = Heating/Cooling Updated In\n\n    Args:\n        super_group (dict): the super group to extract terms from\n\n    Returns:\n        list[str]: list of heating terms\n    \"\"\"\n    amenity_values = []\n    for amenity in super_group.get(\"amenityGroups\", \"\"):  #\n        if not any(\n            AMENITY_GROUP_INCLUDE_PATTERNS.findall(amenity.get(\"groupTitle\", \"\"))\n        ):\n            continue  # this is the name that is bold\n        # these are the bulleted items.\n        for amenity_entry in amenity.get(\"amenityEntries\", \"\"):\n            # if == \"\", then item is dangling (no word before colon). give the same treatment to \"utilities: ...\" as if it were ==\"\"\n            amenity_name = amenity_entry.get(\"amenityName\", \"\")\n\n            if amenity_name and not any(\n                re.compile(\"utilit\", re.I).findall(amenity_name)\n            ):\n                # filter the before colon. first if is to have stricter capture rule when amenity item is \"Utilities: Natural gas, heat pump, ...\"\n                if any(\n                    AMENITY_NAME_INCLUDE_PATTERNS.findall(amenity_name)\n                ) and not any(AMENITY_NAME_EXCLUDE_PATTERNS.findall(amenity_name)):\n                    amenity_values.extend(\n                        [\n                            value\n                            for value in amenity_entry.get(\"amenityValues\", \"\")\n                            if any(\n                                regex.findall(value)\n                                for regex in AFTER_COLON_FUEL_AND_APPLIANCE_INCLUDE_PATTERNS\n                            )\n                            and not any(AFTER_COLON_EXCLUDE_PATTERNS.findall(value))\n                        ]\n                    )\n            else:\n                # filter for appliance if dangling or in utilities bullet item\n                amenity_values.extend(\n                    [\n                        value\n                        for value in amenity_entry.get(\"amenityValues\", \"\")\n                        if any(\n                            regex.findall(value)\n                            for regex in APPLIANCE_HEATING_RELATED_PATTERNS\n                        )\n                    ]\n                )\n    return amenity_values\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_heating_terms_dict_from_listing","title":"<code>get_heating_terms_dict_from_listing(address_and_url_list)</code>","text":"<p>Generate a filled out dictionary based on <code>self.column_dict</code> and the contents of :meth:get_heating_info_from_super_group(address_url_list).</p> TODO <p>Since addresses can be doubled and it is random which one gets chosen, just printing listing url so that we can see which one has been chosen</p> <p>Parameters:</p> Name Type Description Default <code>address_and_url_list</code> <code>list[str]</code> <p>address in the first position, and the listing URL in the second position</p> required <p>Returns:</p> Type Description <code>dict[str, bool]</code> <p>dict[str, bool]: the filled out <code>self.column_dict</code> for the supplied address/listing URL</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_heating_terms_dict_from_listing(\n    self, address_and_url_list: list[str]\n) -&gt; dict[str, bool]:\n    \"\"\"Generate a filled out dictionary based on `self.column_dict` and the contents of :meth:get_heating_info_from_super_group(address_url_list).\n\n    TODO:\n        Since addresses can be doubled and it is random which one gets chosen, just printing listing url so that we can see which one has been chosen\n\n    Args:\n        address_and_url_list (list[str]): address in the first position, and the listing URL in the second position\n\n    Returns:\n        dict[str, bool]: the filled out `self.column_dict` for the supplied address/listing URL\n    \"\"\"\n    address = address_and_url_list[0]\n    listing_url = address_and_url_list[1]\n    terms = []\n\n    super_groups = self.get_super_groups_from_url(listing_url)\n    if super_groups is None:\n        log(\n            \"No amenities found\", \"info\"\n        )  # this and \"There was no heating information for {address}\" should be made in caller?\n        return copy.deepcopy(self.column_dict)\n    for super_group in super_groups:  # dict\n        if any(\n            SUPER_GROUP_INCLUDE_PATTERNS.findall(super_group.get(\"titleString\", \"\"))\n        ):\n            terms.extend(\n                self.get_heating_info_from_super_group(super_group)\n            )  # this will be like [gas, electricity, heat pump]\n    if len(terms) == 0:\n        log(\n            f\"There was no heating information for {urlparse(listing_url).path}\",\n            \"info\",\n        )\n        return copy.deepcopy(self.column_dict)\n\n    # categorize the correct dict and return\n    master_dict = copy.deepcopy(self.column_dict)\n    for input_string in terms:\n        log(f\"{input_string = }\", \"debug\")\n        result = {}\n        for key, pattern in CATEGORY_PATTERNS.items():\n            if bool(re.search(pattern, input_string)):\n                result[key] = True\n                log(f\"Pattern matched on {key, pattern = }\", \"debug\")\n            log(f\"Pattern did not match on {key, pattern = }\", \"debug\")\n        for key in result.keys():\n            master_dict[key] = result[key] | master_dict[key]\n\n    # You'll have to df.unnest this for use in a dataframe\n    log(f\"{terms = }\", \"debug\")\n    log(f\"{master_dict = }\", \"debug\")\n    log(f\"Heating amenities found for {address}.\", \"info\")\n    return master_dict\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_house_attributes_from_metro","title":"<code>get_house_attributes_from_metro(msa_name, search_filters, use_cached_gis_csv_csv=False)</code>","text":"<p>Main function. Get the heating attributes of a Metropolitan Statistical Area.</p> TODO <p>statistics on metropolitan Log statistics about the heating outlook of a metro.</p> <p>Parameters:</p> Name Type Description Default <code>msa_name</code> <code>str</code> <p>Metropolitan Statistical Area name</p> required <code>search_filters</code> <code>dict[str, Any]</code> <p>search filters</p> required <code>use_cached_gis_csv_csv</code> <code>bool</code> <p>Whether to use an already made GIS CSV DataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>None if there were no houses found in the metro</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_house_attributes_from_metro(\n    self,\n    msa_name: str,\n    search_filters: dict[str, Any],\n    use_cached_gis_csv_csv: bool = False,\n) -&gt; None:\n    \"\"\"Main function. Get the heating attributes of a Metropolitan Statistical Area.\n\n    TODO:\n        statistics on metropolitan\n        Log statistics about the heating outlook of a metro.\n\n    Args:\n        msa_name (str): Metropolitan Statistical Area name\n        search_filters (dict[str, Any]): search filters\n        use_cached_gis_csv_csv (bool, optional): Whether to use an already made GIS CSV DataFrame. Defaults to False.\n\n    Returns:\n        None: None if there were no houses found in the metro\n    \"\"\"\n    msa_name_file_safe = msa_name.strip().replace(\", \", \"_\").replace(\" \", \"_\")\n    metro_output_dir_path = Path(OUTPUT_DIR_PATH) / msa_name_file_safe\n\n    if use_cached_gis_csv_csv:\n        log(\"Loading csv from cache.\", \"info\")\n        try:\n            search_page_csvs_df = pl.read_csv(\n                metro_output_dir_path / (msa_name_file_safe + \".csv\"),\n                dtypes=self.DESIRED_CSV_SCHEMA,\n            )\n            log(\n                f\"Loading csv from {metro_output_dir_path / (msa_name_file_safe + \".csv\")} is complete.\",\n                \"info\",\n            )\n        except FileNotFoundError:\n            log(\n                f\"Loading csv from {metro_output_dir_path / (msa_name_file_safe + \".csv\")} has failed, continuing with API search.\",\n                \"info\",\n            )\n            search_page_csvs_df = self.get_gis_csv_for_zips_in_metro_with_filters(\n                msa_name, search_filters\n            )\n    else:\n        search_page_csvs_df = self.get_gis_csv_for_zips_in_metro_with_filters(\n            msa_name, search_filters\n        )\n\n    if search_page_csvs_df is None:\n        log(f\"No houses found within {msa_name}. Try relaxing filters.\", \"info\")\n        return None\n\n    url_col_name = \"URL (SEE https://www.redfin.com/buy-a-home/comparative-market-analysis FOR INFO ON PRICING)\"\n    search_page_csvs_df = search_page_csvs_df.filter(\n        (~pl.col(url_col_name).str.contains(\"(?i)unknown\"))\n        .and_(pl.col(\"ADDRESS\").str.len_chars().gt(0))\n        .and_(pl.col(\"SQUARE FEET\").is_not_null())\n        .and_(pl.col(\"YEAR BUILT\").is_not_null())\n    )\n    # .unique(subset=[\"LATITUDE\", \"LONGITUDE\"], maintain_order=True)\n    # sometimes when there are two of the same listings you'll see the lot and the house. cant determine at this stage, so just leaving duplicates. hopefully this can be handled in viewer\n    # also somehow gets GIS-CSV for search pages that dont allow it\n\n    log(f\"Found {search_page_csvs_df.height} possible houses in {msa_name}\", \"info\")\n    os.makedirs(metro_output_dir_path, exist_ok=True)\n    log(\n        f\"Writing csv for metro to {metro_output_dir_path / (msa_name_file_safe + \".csv\")}\",\n        \"debug\",\n    )\n    search_page_csvs_df.write_csv(\n        metro_output_dir_path / (msa_name_file_safe + \".csv\")\n    )\n\n    # go through whole csv and get the house attributes for each house. then partition the dataframe by ZIP and save files\n\n    log(\"Starting lookups on listing URLS\", \"info\")\n    log(\n        f\"Unique ZIP codes: {search_page_csvs_df[\"ZIP OR POSTAL CODE\"].n_unique()}\",\n        \"info\",\n    )\n    log(\n        f\"Estimated completion time: {search_page_csvs_df.height * 3.58} seconds\",\n        \"info\",\n    )\n\n    list_of_dfs_by_zip = search_page_csvs_df.partition_by(\"ZIP OR POSTAL CODE\")\n\n    for df_of_zip in list_of_dfs_by_zip:\n        df_of_zip = (\n            df_of_zip.with_columns(\n                pl.concat_list([pl.col(\"ADDRESS\"), pl.col(url_col_name)])\n                .map_elements(self.get_heating_terms_dict_from_listing)\n                .alias(\"nest\")\n            )\n            .drop(url_col_name)\n            .unnest(\"nest\")\n        )\n\n        zip = df_of_zip.select(\"ZIP OR POSTAL CODE\").item(0, 0)\n        df_of_zip.write_csv(f\"{metro_output_dir_path}{os.sep}{zip}.csv\")\n\n    # log(f\"In {msa_name}, there are {} homes with Electric fuel, {} homes with Natural Gas, {} homes with Propane, {} homes with Diesel/Heating Oil, {} homes with Wood/Pellet, {} homes with Solar Heating, {} homes with Heat Pumps, {} homes with Baseboard, {} homes with Furnace, {} homes with Boiler, {} homes with Radiator, {} homes with Radiant Floor\")\n    log(f\"Done with searching houses in {msa_name}!\", \"info\")\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_region_info_from_zipcode","title":"<code>get_region_info_from_zipcode(zip_code)</code>","text":"<p>Get the region ifo from a ZIP code.</p> <p>Parameters:</p> Name Type Description Default <code>zip_code</code> <code>str</code> <p>the ZIP code</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>response</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_region_info_from_zipcode(self, zip_code: str) -&gt; Any:\n    \"\"\"Get the region ifo from a ZIP code.\n\n    Args:\n        zip_code (str): the ZIP code\n\n    Returns:\n        Any: response\n    \"\"\"\n    return self.rf.meta_request(\n        \"api/region\", {\"region_id\": zip_code, \"region_type\": 2, \"tz\": True, \"v\": 8}\n    )\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.get_super_groups_from_url","title":"<code>get_super_groups_from_url(listing_url)</code>","text":"<p>Get super group list from listing url.</p> <p>Parameters:</p> Name Type Description Default <code>listing_url</code> <code>str</code> <p>The path part of the listing URL. This is without the \"redfin.com\" part. Include the first forward slash</p> required <p>Returns:</p> Type Description <code>list | None</code> <p>list | None: List of all super groups from a Redfin Url. None if an error is encountered or if no super groups were found</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def get_super_groups_from_url(self, listing_url: str) -&gt; list | None:\n    \"\"\"Get super group list from listing url.\n\n    Args:\n        listing_url (str): The path part of the listing URL. This is without the \"redfin.com\" part. Include the first forward slash\n\n    Returns:\n        list | None: List of all super groups from a Redfin Url. None if an error is encountered or if no super groups were found\n    \"\"\"\n    if \"redfin\" in listing_url:\n        listing_url = urlparse(listing_url).path\n\n    try:\n        time.sleep(random.uniform(1.2, 2.1))\n        initial_info = self.rf.initial_info(listing_url)\n    except json.JSONDecodeError:\n        log(f\"Could not get initial info for {listing_url =}\", \"warn\")\n        return None\n    try:\n        property_id = initial_info[\"payload\"][\"propertyId\"]\n    except KeyError:\n        log(\"Could not find property id\", \"critical\")\n        return None\n    try:\n        listing_id = initial_info[\"payload\"][\"listingId\"]\n    except KeyError:\n        listing_id = None\n        log(\n            \"Could not find listing id. Will try to continue. if errors in final zip csv, this might be the issue\",\n            \"warn\",\n        )\n    try:\n        time.sleep(random.uniform(1.1, 2.1))\n        if listing_id is None:\n            mls_data = self.working_below_the_fold(property_id)\n        else:\n            mls_data = self.working_below_the_fold(property_id, listing_id)\n    except json.JSONDecodeError:\n        log(f\"Could not find mls details for {listing_url = }\", \"warn\")\n        return None\n    try:\n        super_groups = mls_data[\"payload\"][\"amenitiesInfo\"][\"superGroups\"]\n    except KeyError:\n        log(f\"Could not find property details for {listing_url = }\", \"warn\")\n        return None\n    return super_groups\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.meta_request_download","title":"<code>meta_request_download(url, search_params)</code>","text":"<p>Method for downloading objects from Redfin.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>the Redfin URL</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the unicode text response</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def meta_request_download(self, url: str, search_params) -&gt; str:\n    \"\"\"Method for downloading objects from Redfin.\n\n    Args:\n        url (str): the Redfin URL\n\n    Returns:\n        str: the unicode text response\n    \"\"\"\n    response = requests.get(\n        self.rf.base + url, params=search_params, headers=self.rf.user_agent_header\n    )\n    log(response.request.url, \"debug\")\n    response.raise_for_status()\n    return response.text\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.set_search_params","title":"<code>set_search_params(zip, search_filters)</code>","text":"<p>Set the parameters for searching by ZIP code.</p> <p>Parameters:</p> Name Type Description Default <code>zip</code> <code>str</code> <p>the ZIP code</p> required <code>search_filters</code> <code>dict[str, Any]</code> <p>search filters for appending to a gis-csv path</p> required Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def set_search_params(self, zip: str, search_filters: dict[str, Any]) -&gt; None:\n    \"\"\"Set the parameters for searching by ZIP code.\n\n    Args:\n        zip (str): the ZIP code\n        search_filters (dict[str, Any]): search filters for appending to a gis-csv path\n    \"\"\"\n    try:\n        region_info = self.get_region_info_from_zipcode(zip)\n    except json.JSONDecodeError:\n        log(f\"Could not decode region info for {zip}.\", \"warn\")\n        return None\n    except HTTPError:\n        log(f\"Could not retrieve region info for {zip}.\", \"warn\")\n        return None\n\n    if search_filters.get(\"for sale sold\") == \"Sold\":\n        sort_order = self.SortOrder.MOST_RECENTLY_SOLD.value\n    else:\n        sort_order = self.SortOrder.NEWEST.value\n    # TODO make sure to fix filtering so that its not just \"single family homes\"\n\n    try:\n        market = region_info[\"payload\"][\"rootDefaults\"][\"market\"]\n        region_id = region_info[\"payload\"][\"rootDefaults\"][\"region_id\"]\n        status = str(region_info[\"payload\"][\"rootDefaults\"][\"status\"])\n    except KeyError:\n        log(\"Market, region, or status could not be identified \", \"warn\")\n        return None\n\n    self.search_params = {\n        \"al\": 1,\n        \"has_deal\": \"false\",\n        \"has_dishwasher\": \"false\",\n        \"has_laundry_facility\": \"false\",\n        \"has_laundry_hookups\": \"false\",\n        \"has_parking\": \"false\",\n        \"has_pool\": \"false\",\n        \"has_short_term_lease\": \"false\",\n        \"include_pending_homes\": \"false\",  # probably an \"include\" option\n        \"isRentals\": \"false\",\n        \"is_furnished\": \"false\",\n        \"is_income_restricted\": \"false\",\n        \"is_senior_living\": \"false\",\n        \"max_year_built\": search_filters.get(\"max year built\"),\n        \"min_year_built\": search_filters.get(\"min year built\"),\n        \"market\": market,\n        \"min_stories\": search_filters.get(\"min stories\"),\n        \"num_homes\": 350,\n        \"ord\": sort_order,\n        \"page_number\": \"1\",\n        \"pool\": \"false\",\n        \"region_id\": region_id,\n        \"region_type\": \"2\",\n        \"status\": status,\n        \"travel_with_traffic\": \"false\",\n        \"travel_within_region\": \"false\",\n        \"utilities_included\": \"false\",\n        \"v\": \"8\",\n    }\n    if search_filters.get(\"for sale sold\") == \"Sold\":\n        self.search_params[\"sold_within_days\"] = search_filters.get(\"sold within\")\n        self.search_params[\"status\"] = 9\n    else:\n        self.search_params[\"sf\"] = \"1, 2, 3, 4, 5, 6, 7\"\n        match [\n            search_filters.get(\"status coming soon\"),\n            search_filters.get(\"status active\"),\n            search_filters.get(\"status pending\"),\n        ]:\n            case [True, False, False]:\n                status = \"8\"\n            case [False, True, False]:\n                status = \"1\"\n            case [False, False, True]:\n                status = \"130\"\n            case [True, True, False]:\n                status = \"9\"\n            case [False, True, True]:\n                status = \"139\"\n            case [True, False, True]:\n                status = \"138\"\n            case [True, True, True]:\n                status = \"139\"\n\n        self.search_params[\"status\"] = status\n\n    if (max_sqft := search_filters.get(\"max sqft\")) != \"None\":\n        self.search_params[\"max_sqft\"] = max_sqft\n    if (min_sqft := search_filters.get(\"min sqft\")) != \"None\":\n        self.search_params[\"min_sqft\"] = min_sqft\n\n    if (max_price := search_filters.get(\"max price\")) != \"None\":\n        self.search_params[\"max_price\"] = max_price\n    if (min_price := search_filters.get(\"min price\")) != \"None\":\n        self.search_params[\"min_price\"] = min_price\n\n    houses = \"\"  # figure out how to join into comma string\n    if search_filters.get(\"house type house\") is True:\n        houses = houses + \"1\"\n    if search_filters.get(\"house type condo\") is True:\n        houses = houses + \"2\"\n    if search_filters.get(\"house type townhouse\") is True:\n        houses = houses + \"3\"\n    if search_filters.get(\"house type mul fam\") is True:\n        houses = houses + \"4\"\n\n    self.search_params[\"uipt\"] = \",\".join(list(houses))\n</code></pre>"},{"location":"backend/redfinscraper/#backend.redfinscraper.RedfinApi.working_below_the_fold","title":"<code>working_below_the_fold(property_id, listing_id='')</code>","text":"<p>A below_the_fold method that accepts a listing ID. Note:     If you can get the listing ID, make sure to pass it to this function. You will possibly get incorrect data if you do not pass it</p> <p>Parameters:</p> Name Type Description Default <code>property_id</code> <code>str</code> <p>the property ID</p> required <code>listing_id</code> <code>str</code> <p>The listing ID. Defaults to False.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>response</p> Source code in <code>src\\backend\\redfinscraper.py</code> <pre><code>def working_below_the_fold(self, property_id: str, listing_id: str = \"\") -&gt; Any:\n    \"\"\"A below_the_fold method that accepts a listing ID.\n    Note:\n        If you can get the listing ID, make sure to pass it to this function. You will possibly get incorrect data if you do not pass it\n\n    Args:\n        property_id (str): the property ID\n        listing_id (str): The listing ID. Defaults to False.\n\n    Returns:\n        Any: response\n    \"\"\"\n    if listing_id:\n        params = {\n            \"accessLevel\": 1,\n            \"propertyId\": property_id,\n            \"listingId\": listing_id,\n            \"pageType\": 1,\n        }\n    else:\n        params = {\n            \"accessLevel\": 1,\n            \"propertyId\": property_id,\n            \"pageType\": 1,\n        }\n    return self.rf.meta_request(\"/api/home/details/belowTheFold\", params)\n</code></pre>"},{"location":"backend/secondarydata/","title":"Secondarydata","text":""},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever","title":"<code>CensusDataRetriever</code>","text":"<p>Interact with the Census data API.</p> Note <p>ACS5 paths can be found here: https://api.census.gov/data/2019/acs/acs5.html</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>class CensusDataRetriever:\n    \"\"\"Interact with the Census data API.\n\n    Note:\n        ACS5 paths can be found here: https://api.census.gov/data/2019/acs/acs5.html\"\"\"\n\n    def __init__(self) -&gt; None:\n        self.base_url = \"https://data.census.gov/\"\n        # https://api.census.gov/data/2021/acs/acs5/profile/variables.html\n        self.api_key = os.getenv(\"CENSUS_API_KEY\")\n        if self.api_key is None:\n            log(\n                \"No Census API key found in a .env file in project directory. please request a key at https://api.census.gov/data/key_signup.html\",\n                \"critical\",\n            )\n            exit()\n        self.MAX_COL_NAME_LENGTH = 80\n\n    def _get(self, url: str) -&gt; requests.Response | None:\n        r = requests.get(url, timeout=65)\n        if r.status_code == 400:\n            log(f\"Unknown variable {r.text.split(\"variable \")[-1]}\", \"info\")\n            return None\n        return r\n\n    def get_and_cache_data(\n        self, file_name: str, url_to_lookup_on_miss: str\n    ) -&gt; dict[str, str] | bool:\n        \"\"\"Cache files.\n\n        Args:\n            file_name (str): file name to save/lookup\n            url_to_lookup_on_miss (str): the Census url to lookup\n\n        Returns:\n            bool | dict[str, str] | None | Any: the dict of `tablename: label` or\n        \"\"\"\n        CENSUS_DATA_DIR_PATH.mkdir(parents=True, exist_ok=True)\n\n        my_json = None\n\n        try:\n            with open(CENSUS_DATA_DIR_PATH / file_name, mode=\"r\") as f:\n                log(f\"Reading {file_name}\", \"debug\")\n                try:\n                    my_json = json.load(f)\n                except json.JSONDecodeError:\n                    log(\"Could not decode cached file\", \"error\")\n                    return False\n        except FileNotFoundError:\n            req = self._get(url_to_lookup_on_miss)\n            if req is None:\n                log(f\"Could not find census file {req = }\", \"error\")\n                return False\n            req.raise_for_status()\n            my_json = req.json()\n            with open(CENSUS_DATA_DIR_PATH / file_name, \"w\") as f:\n                json.dump(my_json, f)\n\n        return my_json\n\n    def get_race_makeup_by_zcta(self, zcta: str) -&gt; str | None:\n        \"\"\"Get race make up by zcta from. DO NOT USE\n\n        Note:\n            use `get_table_group_for_zcta_by_state_by_year`\n\n        Args:\n            zcta (str): zcta\n\n        Returns:\n            str | None: text or none\n        \"\"\"\n        # get white, black, american indian/native alaskan, asian, NH/PI, other. note that these are estimates, margin of error can be had with \"M\"\n        req = self._get(\n            f\"https://api.census.gov/data/2021/acs/acs5/profile?get=DP05_0064E,DP05_0065E,DP05_0066E,DP05_0067E,DP05_0068E,DP05_0069E&amp;for=zip%20code%20tabulation%20area:{zcta}&amp;key={self.api_key}\"\n        )\n        if req is None:\n            return None\n        return req.text\n\n    def get_acs5_profile_table_to_group_name(\n        self, table: str, year: str\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Get a JSON representation of a table's attributes.\n\n        Note:\n            Tables must be:\n                * DP02\n                * DP02PR\n                * DP03\n                * DP04\n                * DP05\n\n            Returned object will have entries similar to:\n            ```json\n            \"DP05_0037M\": {\n                \"label\": \"Margin of Error!!RACE!!Total population!!One race!!White\",\n                \"concept\": \"ACS DEMOGRAPHIC AND HOUSING ESTIMATES\",\n                \"predicateType\": \"int\",\n                \"group\": \"DP05\",\n                \"limit\": 0,\n                \"predicateOnly\": true\n            }\n            ```\n\n        Args:\n            table (str): the table to lookup\n            year (str): which acs5 year to look up\n\n        Returns:\n            str | Any: json object\n        \"\"\"\n        file_name = f\"{year}-acs5-profile-groups-{table}.json\"\n        groups_url = (\n            f\"https://api.census.gov/data/{year}/acs/acs5/profile/groups/{table}.json\"\n        )\n        groups_to_label_translation = self.get_and_cache_data(file_name, groups_url)\n        if groups_to_label_translation is False:\n            log(\"Something is wrong with groups label dict\", \"warn\")\n            return None\n        return groups_to_label_translation[\"variables\"]  # type: ignore\n\n    def translate_and_truncate_unique_acs5_profile_groups_to_labels_for_header_list(\n        self, headers: list[str], table: str, year: str\n    ) -&gt; None:\n        \"\"\"Get the label name for a table and row for the acs5 profile surveys.\n\n        Args:\n            headers (list[str]): header row\n            table (str): have to look again\n            year (str): the year\n\n        Returns:\n            None: translates the list of table_row_selector to its english label\n        \"\"\"\n        # is going to read the file multiple times, save last req as {\"table\": req_json[table]...} for this?\n        groups_to_label_translation_dict = self.get_acs5_profile_table_to_group_name(\n            table, year\n        )\n        if groups_to_label_translation_dict is None:\n            log(\"Could not translate headers\", \"warn\")\n            return groups_to_label_translation_dict\n\n        for idx, header in enumerate(headers):\n            new_col_name_dict = groups_to_label_translation_dict.get(header)\n            if new_col_name_dict is None:\n                # returns none if not in dict, means we have custom name and can continue\n                continue\n            new_col_name = new_col_name_dict[\"label\"]\n            # qgis doesnt allow field names of 80+ chars. massage into form, then cut off\n            # delimiter for table subsection\n            new_col_name = re.sub(\"!!\", \" \", new_col_name)\n            new_col_name = re.sub(r\"\\s+\", \" \", new_col_name)\n            # easier to read\n            new_col_name_parts = new_col_name.split(\" \")\n            for idy, no_format in enumerate(new_col_name_parts):\n                new_col_name_parts[idy] = no_format.capitalize()\n            new_col_name = \"\".join(new_col_name_parts)\n            # shortenings to fit length requirement\n            for key, value in replace_dict.items():\n                new_col_name = re.sub(key, value, new_col_name)\n            # limiter\n            new_col_name = new_col_name[\n                : min(len(new_col_name), self.MAX_COL_NAME_LENGTH)\n            ]\n\n            if new_col_name not in headers[:idx]:\n                headers[idx] = new_col_name\n\n    def get_acs5_profile_table_group_for_zcta_by_year(\n        self, table: str, year: str\n    ) -&gt; str:\n        \"\"\"CSV output of an acs 5 year profile survey table.\n\n        TODO:\n            Update func name\n\n        Args:\n            table (str): census demo acs5 table\n            year (str): year to search\n\n        Returns:\n            str: file path where output is saved\n        \"\"\"\n        file_name = f\"{year}-acs-profile-table-{table}.json\"\n        url = f\"https://api.census.gov/data/{year}/acs/acs5/profile?get=group({table})&amp;for=zip%20code%20tabulation%20area:*\"\n        list_of_list_table_json = self.get_and_cache_data(file_name, url)\n\n        if list_of_list_table_json is False:\n            log(\n                f\"Could not load table {table}. Perhaps the api is down or there was an error saving/reading the file.\",\n                \"warn\",\n            )\n            return \"\"\n\n        self.translate_and_truncate_unique_acs5_profile_groups_to_labels_for_header_list(\n            list_of_list_table_json[0],  # type: ignore\n            table,\n            year,  # type: ignore\n        )\n\n        df = pl.DataFrame(list_of_list_table_json, orient=\"row\")\n        # funky stuff to get the first list to be the name of the columns\n        df = (\n            df.rename(df.head(1).to_dicts().pop())\n            .slice(1)  # type: ignore\n            .drop(\"NAME\", cs.matches(\"(?i)^(ann)\"), cs.matches(f\"(?i){table}\"))\n            .rename({\"zip code tabulation area\": \"ZCTA\"})\n            .cast(\n                {\n                    \"ZCTA\": pl.Int32,\n                }\n            )\n        )\n        file_path = CENSUS_DATA_DIR_PATH / \"acs5-profile-group-{table}-zcta.csv\"\n        df.write_csv(file_path)\n        return str(file_path)\n\n    def get_acs5_subject_table_to_group_name(\n        self, table: str, year: str\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Get a JSON representation of a table's attributes.\n\n        Note:\n            Tables can be found at: https://www.census.gov/acs/www/data/data-tables-and-tools/subject-tables/\n\n            Returned object will have entries similar to:\n            ```json\n            \"DP05_0037M\": {\n                \"label\": \"Margin of Error!!RACE!!Total population!!One race!!White\",\n                \"concept\": \"ACS DEMOGRAPHIC AND HOUSING ESTIMATES\",\n                \"predicateType\": \"int\",\n                \"group\": \"DP05\",\n                \"limit\": 0,\n                \"predicateOnly\": true\n            }\n            ```\n\n        Args:\n            table (str): the table to lookup\n            year (str): which acs5 year to look up\n\n        Returns:\n            str | Any: variables\n        \"\"\"\n        file_name = f\"{year}-acs5-subject-groups-{table}.json\"\n        groups_url = (\n            f\"https://api.census.gov/data/{year}/acs/acs5/subject/groups/{table}.json\"\n        )\n        groups_to_label_translation = self.get_and_cache_data(file_name, groups_url)\n        if groups_to_label_translation is False:\n            log(\"Something is wrong with groups label dict\", \"warn\")\n            return None\n        return groups_to_label_translation[\"variables\"]  # type: ignore\n\n    def translate_and_truncate_unique_acs5_subject_groups_to_labels_for_header_list(\n        self, headers: list[str], table: str, year: str\n    ) -&gt; None:\n        \"\"\"Gets the label name for a table and row for the acs5 profile surveys.\n\n        Args:\n            headers (list[str]): headers\n            table (str): table\n            year (str): year\n        \"\"\"\n        # is going to read the file multiple times, save last req as {\"table\": req_json[table]...} for this?\n        groups_to_label_translation_dict = self.get_acs5_subject_table_to_group_name(\n            table, year\n        )\n        if groups_to_label_translation_dict is None:\n            log(\"Could not translate headers\", \"warn\")\n            return groups_to_label_translation_dict\n\n        for idx, header in enumerate(headers):\n            new_col_name_dict = groups_to_label_translation_dict.get(header)\n            if new_col_name_dict is None:\n                # returns none if not in dict, means we have custom name and can continue\n                continue\n            new_col_name = new_col_name_dict[\"label\"]\n            # qgis doesnt allow field names of 80+ chars. massage into form, then cut off\n            # delimiter for table subsection\n            new_col_name = re.sub(\"!!\", \" \", new_col_name)\n            new_col_name = re.sub(r\"\\s+\", \" \", new_col_name)\n            # easier to read\n            new_col_name_parts = new_col_name.split(\" \")\n            for idy, no_format in enumerate(new_col_name_parts):\n                new_col_name_parts[idy] = no_format.capitalize()\n            new_col_name = \"\".join(new_col_name_parts)\n            # shortenings to fit length requirement\n            for key, value in replace_dict.items():\n                new_col_name = re.sub(key, value, new_col_name)\n            # limiter\n            new_col_name = new_col_name[\n                : min(len(new_col_name), self.MAX_COL_NAME_LENGTH)\n            ]\n\n            if new_col_name not in headers[:idx]:\n                headers[idx] = new_col_name\n\n    def get_acs5_subject_table_group_for_zcta_by_year(\n        self, table: str, year: str\n    ) -&gt; str:\n        \"\"\"CSV output of a acs 5 year subject survey table\n\n        Args:\n            table (str): census acs5 table\n            year (str): year to search\n        \"\"\"\n        file_name = f\"{year}-acs-subject-table-{table}.json\"\n        url = f\"https://api.census.gov/data/{year}/acs/acs5/subject?get=group({table})&amp;for=zip%20code%20tabulation%20area:*\"\n        list_of_list_table_json = self.get_and_cache_data(file_name, url)\n\n        if list_of_list_table_json is False:\n            log(\n                f\"Could not load table {table}. Perhaps the api is down or there was an error saving/reading the file.\",\n                \"warn\",\n            )\n            return \"\"\n\n        self.translate_and_truncate_unique_acs5_subject_groups_to_labels_for_header_list(\n            list_of_list_table_json[0],  # type: ignore\n            table,\n            year,  # type: ignore\n        )\n\n        df = pl.DataFrame(list_of_list_table_json, orient=\"row\")\n        # funky stuff to get the first list to be the name of the columns\n        df = (\n            df.rename(df.head(1).to_dicts().pop())\n            .slice(1)  # type: ignore\n            .drop(\"NAME\", cs.matches(\"(?i)^(ann)\"), cs.matches(f\"(?i){table}\"))\n            .rename({\"zip code tabulation area\": \"ZCTA\"})\n            .cast(\n                {\n                    \"ZCTA\": pl.Int32,\n                }\n            )\n        )\n        file_path = CENSUS_DATA_DIR_PATH / \"acs5-subject-group-{table}-zcta.csv\"\n        # may not have to write. but cache func doesn't return whether it hits or not\n        df.write_csv(file_path)\n        return str(file_path)\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.get_acs5_profile_table_group_for_zcta_by_year","title":"<code>get_acs5_profile_table_group_for_zcta_by_year(table, year)</code>","text":"<p>CSV output of an acs 5 year profile survey table.</p> TODO <p>Update func name</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>census demo acs5 table</p> required <code>year</code> <code>str</code> <p>year to search</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>file path where output is saved</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def get_acs5_profile_table_group_for_zcta_by_year(\n    self, table: str, year: str\n) -&gt; str:\n    \"\"\"CSV output of an acs 5 year profile survey table.\n\n    TODO:\n        Update func name\n\n    Args:\n        table (str): census demo acs5 table\n        year (str): year to search\n\n    Returns:\n        str: file path where output is saved\n    \"\"\"\n    file_name = f\"{year}-acs-profile-table-{table}.json\"\n    url = f\"https://api.census.gov/data/{year}/acs/acs5/profile?get=group({table})&amp;for=zip%20code%20tabulation%20area:*\"\n    list_of_list_table_json = self.get_and_cache_data(file_name, url)\n\n    if list_of_list_table_json is False:\n        log(\n            f\"Could not load table {table}. Perhaps the api is down or there was an error saving/reading the file.\",\n            \"warn\",\n        )\n        return \"\"\n\n    self.translate_and_truncate_unique_acs5_profile_groups_to_labels_for_header_list(\n        list_of_list_table_json[0],  # type: ignore\n        table,\n        year,  # type: ignore\n    )\n\n    df = pl.DataFrame(list_of_list_table_json, orient=\"row\")\n    # funky stuff to get the first list to be the name of the columns\n    df = (\n        df.rename(df.head(1).to_dicts().pop())\n        .slice(1)  # type: ignore\n        .drop(\"NAME\", cs.matches(\"(?i)^(ann)\"), cs.matches(f\"(?i){table}\"))\n        .rename({\"zip code tabulation area\": \"ZCTA\"})\n        .cast(\n            {\n                \"ZCTA\": pl.Int32,\n            }\n        )\n    )\n    file_path = CENSUS_DATA_DIR_PATH / \"acs5-profile-group-{table}-zcta.csv\"\n    df.write_csv(file_path)\n    return str(file_path)\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.get_acs5_profile_table_to_group_name","title":"<code>get_acs5_profile_table_to_group_name(table, year)</code>","text":"<p>Get a JSON representation of a table's attributes.</p> Note <p>Tables must be:     * DP02     * DP02PR     * DP03     * DP04     * DP05</p> <p>Returned object will have entries similar to: <pre><code>\"DP05_0037M\": {\n    \"label\": \"Margin of Error!!RACE!!Total population!!One race!!White\",\n    \"concept\": \"ACS DEMOGRAPHIC AND HOUSING ESTIMATES\",\n    \"predicateType\": \"int\",\n    \"group\": \"DP05\",\n    \"limit\": 0,\n    \"predicateOnly\": true\n}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>the table to lookup</p> required <code>year</code> <code>str</code> <p>which acs5 year to look up</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>str | Any: json object</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def get_acs5_profile_table_to_group_name(\n    self, table: str, year: str\n) -&gt; dict[str, Any] | None:\n    \"\"\"Get a JSON representation of a table's attributes.\n\n    Note:\n        Tables must be:\n            * DP02\n            * DP02PR\n            * DP03\n            * DP04\n            * DP05\n\n        Returned object will have entries similar to:\n        ```json\n        \"DP05_0037M\": {\n            \"label\": \"Margin of Error!!RACE!!Total population!!One race!!White\",\n            \"concept\": \"ACS DEMOGRAPHIC AND HOUSING ESTIMATES\",\n            \"predicateType\": \"int\",\n            \"group\": \"DP05\",\n            \"limit\": 0,\n            \"predicateOnly\": true\n        }\n        ```\n\n    Args:\n        table (str): the table to lookup\n        year (str): which acs5 year to look up\n\n    Returns:\n        str | Any: json object\n    \"\"\"\n    file_name = f\"{year}-acs5-profile-groups-{table}.json\"\n    groups_url = (\n        f\"https://api.census.gov/data/{year}/acs/acs5/profile/groups/{table}.json\"\n    )\n    groups_to_label_translation = self.get_and_cache_data(file_name, groups_url)\n    if groups_to_label_translation is False:\n        log(\"Something is wrong with groups label dict\", \"warn\")\n        return None\n    return groups_to_label_translation[\"variables\"]  # type: ignore\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.get_acs5_subject_table_group_for_zcta_by_year","title":"<code>get_acs5_subject_table_group_for_zcta_by_year(table, year)</code>","text":"<p>CSV output of a acs 5 year subject survey table</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>census acs5 table</p> required <code>year</code> <code>str</code> <p>year to search</p> required Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def get_acs5_subject_table_group_for_zcta_by_year(\n    self, table: str, year: str\n) -&gt; str:\n    \"\"\"CSV output of a acs 5 year subject survey table\n\n    Args:\n        table (str): census acs5 table\n        year (str): year to search\n    \"\"\"\n    file_name = f\"{year}-acs-subject-table-{table}.json\"\n    url = f\"https://api.census.gov/data/{year}/acs/acs5/subject?get=group({table})&amp;for=zip%20code%20tabulation%20area:*\"\n    list_of_list_table_json = self.get_and_cache_data(file_name, url)\n\n    if list_of_list_table_json is False:\n        log(\n            f\"Could not load table {table}. Perhaps the api is down or there was an error saving/reading the file.\",\n            \"warn\",\n        )\n        return \"\"\n\n    self.translate_and_truncate_unique_acs5_subject_groups_to_labels_for_header_list(\n        list_of_list_table_json[0],  # type: ignore\n        table,\n        year,  # type: ignore\n    )\n\n    df = pl.DataFrame(list_of_list_table_json, orient=\"row\")\n    # funky stuff to get the first list to be the name of the columns\n    df = (\n        df.rename(df.head(1).to_dicts().pop())\n        .slice(1)  # type: ignore\n        .drop(\"NAME\", cs.matches(\"(?i)^(ann)\"), cs.matches(f\"(?i){table}\"))\n        .rename({\"zip code tabulation area\": \"ZCTA\"})\n        .cast(\n            {\n                \"ZCTA\": pl.Int32,\n            }\n        )\n    )\n    file_path = CENSUS_DATA_DIR_PATH / \"acs5-subject-group-{table}-zcta.csv\"\n    # may not have to write. but cache func doesn't return whether it hits or not\n    df.write_csv(file_path)\n    return str(file_path)\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.get_acs5_subject_table_to_group_name","title":"<code>get_acs5_subject_table_to_group_name(table, year)</code>","text":"<p>Get a JSON representation of a table's attributes.</p> Note <p>Tables can be found at: https://www.census.gov/acs/www/data/data-tables-and-tools/subject-tables/</p> <p>Returned object will have entries similar to: <pre><code>\"DP05_0037M\": {\n    \"label\": \"Margin of Error!!RACE!!Total population!!One race!!White\",\n    \"concept\": \"ACS DEMOGRAPHIC AND HOUSING ESTIMATES\",\n    \"predicateType\": \"int\",\n    \"group\": \"DP05\",\n    \"limit\": 0,\n    \"predicateOnly\": true\n}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>the table to lookup</p> required <code>year</code> <code>str</code> <p>which acs5 year to look up</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>str | Any: variables</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def get_acs5_subject_table_to_group_name(\n    self, table: str, year: str\n) -&gt; dict[str, Any] | None:\n    \"\"\"Get a JSON representation of a table's attributes.\n\n    Note:\n        Tables can be found at: https://www.census.gov/acs/www/data/data-tables-and-tools/subject-tables/\n\n        Returned object will have entries similar to:\n        ```json\n        \"DP05_0037M\": {\n            \"label\": \"Margin of Error!!RACE!!Total population!!One race!!White\",\n            \"concept\": \"ACS DEMOGRAPHIC AND HOUSING ESTIMATES\",\n            \"predicateType\": \"int\",\n            \"group\": \"DP05\",\n            \"limit\": 0,\n            \"predicateOnly\": true\n        }\n        ```\n\n    Args:\n        table (str): the table to lookup\n        year (str): which acs5 year to look up\n\n    Returns:\n        str | Any: variables\n    \"\"\"\n    file_name = f\"{year}-acs5-subject-groups-{table}.json\"\n    groups_url = (\n        f\"https://api.census.gov/data/{year}/acs/acs5/subject/groups/{table}.json\"\n    )\n    groups_to_label_translation = self.get_and_cache_data(file_name, groups_url)\n    if groups_to_label_translation is False:\n        log(\"Something is wrong with groups label dict\", \"warn\")\n        return None\n    return groups_to_label_translation[\"variables\"]  # type: ignore\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.get_and_cache_data","title":"<code>get_and_cache_data(file_name, url_to_lookup_on_miss)</code>","text":"<p>Cache files.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>file name to save/lookup</p> required <code>url_to_lookup_on_miss</code> <code>str</code> <p>the Census url to lookup</p> required <p>Returns:</p> Type Description <code>dict[str, str] | bool</code> <p>bool | dict[str, str] | None | Any: the dict of <code>tablename: label</code> or</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def get_and_cache_data(\n    self, file_name: str, url_to_lookup_on_miss: str\n) -&gt; dict[str, str] | bool:\n    \"\"\"Cache files.\n\n    Args:\n        file_name (str): file name to save/lookup\n        url_to_lookup_on_miss (str): the Census url to lookup\n\n    Returns:\n        bool | dict[str, str] | None | Any: the dict of `tablename: label` or\n    \"\"\"\n    CENSUS_DATA_DIR_PATH.mkdir(parents=True, exist_ok=True)\n\n    my_json = None\n\n    try:\n        with open(CENSUS_DATA_DIR_PATH / file_name, mode=\"r\") as f:\n            log(f\"Reading {file_name}\", \"debug\")\n            try:\n                my_json = json.load(f)\n            except json.JSONDecodeError:\n                log(\"Could not decode cached file\", \"error\")\n                return False\n    except FileNotFoundError:\n        req = self._get(url_to_lookup_on_miss)\n        if req is None:\n            log(f\"Could not find census file {req = }\", \"error\")\n            return False\n        req.raise_for_status()\n        my_json = req.json()\n        with open(CENSUS_DATA_DIR_PATH / file_name, \"w\") as f:\n            json.dump(my_json, f)\n\n    return my_json\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.get_race_makeup_by_zcta","title":"<code>get_race_makeup_by_zcta(zcta)</code>","text":"<p>Get race make up by zcta from. DO NOT USE</p> Note <p>use <code>get_table_group_for_zcta_by_state_by_year</code></p> <p>Parameters:</p> Name Type Description Default <code>zcta</code> <code>str</code> <p>zcta</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: text or none</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def get_race_makeup_by_zcta(self, zcta: str) -&gt; str | None:\n    \"\"\"Get race make up by zcta from. DO NOT USE\n\n    Note:\n        use `get_table_group_for_zcta_by_state_by_year`\n\n    Args:\n        zcta (str): zcta\n\n    Returns:\n        str | None: text or none\n    \"\"\"\n    # get white, black, american indian/native alaskan, asian, NH/PI, other. note that these are estimates, margin of error can be had with \"M\"\n    req = self._get(\n        f\"https://api.census.gov/data/2021/acs/acs5/profile?get=DP05_0064E,DP05_0065E,DP05_0066E,DP05_0067E,DP05_0068E,DP05_0069E&amp;for=zip%20code%20tabulation%20area:{zcta}&amp;key={self.api_key}\"\n    )\n    if req is None:\n        return None\n    return req.text\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.translate_and_truncate_unique_acs5_profile_groups_to_labels_for_header_list","title":"<code>translate_and_truncate_unique_acs5_profile_groups_to_labels_for_header_list(headers, table, year)</code>","text":"<p>Get the label name for a table and row for the acs5 profile surveys.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>list[str]</code> <p>header row</p> required <code>table</code> <code>str</code> <p>have to look again</p> required <code>year</code> <code>str</code> <p>the year</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>translates the list of table_row_selector to its english label</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def translate_and_truncate_unique_acs5_profile_groups_to_labels_for_header_list(\n    self, headers: list[str], table: str, year: str\n) -&gt; None:\n    \"\"\"Get the label name for a table and row for the acs5 profile surveys.\n\n    Args:\n        headers (list[str]): header row\n        table (str): have to look again\n        year (str): the year\n\n    Returns:\n        None: translates the list of table_row_selector to its english label\n    \"\"\"\n    # is going to read the file multiple times, save last req as {\"table\": req_json[table]...} for this?\n    groups_to_label_translation_dict = self.get_acs5_profile_table_to_group_name(\n        table, year\n    )\n    if groups_to_label_translation_dict is None:\n        log(\"Could not translate headers\", \"warn\")\n        return groups_to_label_translation_dict\n\n    for idx, header in enumerate(headers):\n        new_col_name_dict = groups_to_label_translation_dict.get(header)\n        if new_col_name_dict is None:\n            # returns none if not in dict, means we have custom name and can continue\n            continue\n        new_col_name = new_col_name_dict[\"label\"]\n        # qgis doesnt allow field names of 80+ chars. massage into form, then cut off\n        # delimiter for table subsection\n        new_col_name = re.sub(\"!!\", \" \", new_col_name)\n        new_col_name = re.sub(r\"\\s+\", \" \", new_col_name)\n        # easier to read\n        new_col_name_parts = new_col_name.split(\" \")\n        for idy, no_format in enumerate(new_col_name_parts):\n            new_col_name_parts[idy] = no_format.capitalize()\n        new_col_name = \"\".join(new_col_name_parts)\n        # shortenings to fit length requirement\n        for key, value in replace_dict.items():\n            new_col_name = re.sub(key, value, new_col_name)\n        # limiter\n        new_col_name = new_col_name[\n            : min(len(new_col_name), self.MAX_COL_NAME_LENGTH)\n        ]\n\n        if new_col_name not in headers[:idx]:\n            headers[idx] = new_col_name\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.CensusDataRetriever.translate_and_truncate_unique_acs5_subject_groups_to_labels_for_header_list","title":"<code>translate_and_truncate_unique_acs5_subject_groups_to_labels_for_header_list(headers, table, year)</code>","text":"<p>Gets the label name for a table and row for the acs5 profile surveys.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>list[str]</code> <p>headers</p> required <code>table</code> <code>str</code> <p>table</p> required <code>year</code> <code>str</code> <p>year</p> required Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def translate_and_truncate_unique_acs5_subject_groups_to_labels_for_header_list(\n    self, headers: list[str], table: str, year: str\n) -&gt; None:\n    \"\"\"Gets the label name for a table and row for the acs5 profile surveys.\n\n    Args:\n        headers (list[str]): headers\n        table (str): table\n        year (str): year\n    \"\"\"\n    # is going to read the file multiple times, save last req as {\"table\": req_json[table]...} for this?\n    groups_to_label_translation_dict = self.get_acs5_subject_table_to_group_name(\n        table, year\n    )\n    if groups_to_label_translation_dict is None:\n        log(\"Could not translate headers\", \"warn\")\n        return groups_to_label_translation_dict\n\n    for idx, header in enumerate(headers):\n        new_col_name_dict = groups_to_label_translation_dict.get(header)\n        if new_col_name_dict is None:\n            # returns none if not in dict, means we have custom name and can continue\n            continue\n        new_col_name = new_col_name_dict[\"label\"]\n        # qgis doesnt allow field names of 80+ chars. massage into form, then cut off\n        # delimiter for table subsection\n        new_col_name = re.sub(\"!!\", \" \", new_col_name)\n        new_col_name = re.sub(r\"\\s+\", \" \", new_col_name)\n        # easier to read\n        new_col_name_parts = new_col_name.split(\" \")\n        for idy, no_format in enumerate(new_col_name_parts):\n            new_col_name_parts[idy] = no_format.capitalize()\n        new_col_name = \"\".join(new_col_name_parts)\n        # shortenings to fit length requirement\n        for key, value in replace_dict.items():\n            new_col_name = re.sub(key, value, new_col_name)\n        # limiter\n        new_col_name = new_col_name[\n            : min(len(new_col_name), self.MAX_COL_NAME_LENGTH)\n        ]\n\n        if new_col_name not in headers[:idx]:\n            headers[idx] = new_col_name\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever","title":"<code>EIADataRetriever</code>","text":"<p>Interact with the EIA open data API.</p> Note <p>This is the \"manual\" for this API: https://www.eia.gov/opendata/pdf/EIA-APIv2-HandsOn-Webinar-11-Jan-23.pdf</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>class EIADataRetriever:\n    \"\"\"Interact with the EIA open data API.\n\n    Note:\n        This is the \"manual\" for this API:\n        https://www.eia.gov/opendata/pdf/EIA-APIv2-HandsOn-Webinar-11-Jan-23.pdf\n    \"\"\"\n\n    HEATING_OIL_STATES_ABBR = {\n        sts.CT.abbr,\n        sts.DC.abbr,\n        sts.DE.abbr,\n        sts.IA.abbr,\n        sts.IL.abbr,\n        sts.IN.abbr,\n        sts.KS.abbr,\n        sts.KY.abbr,\n        sts.MA.abbr,\n        sts.MD.abbr,\n        sts.ME.abbr,\n        sts.MI.abbr,\n        sts.MN.abbr,\n        sts.MO.abbr,\n        sts.NC.abbr,\n        sts.ND.abbr,\n        sts.NE.abbr,\n        sts.NH.abbr,\n        sts.NJ.abbr,\n        sts.NY.abbr,\n        sts.OH.abbr,\n        sts.PA.abbr,\n        sts.RI.abbr,\n        sts.SD.abbr,\n        sts.VA.abbr,\n        sts.VT.abbr,\n        sts.WI.abbr,\n    }\n\n    PROPANE_STATES_ABBR = {\n        sts.AL.abbr,\n        sts.AR.abbr,\n        sts.CO.abbr,\n        sts.CT.abbr,\n        sts.DE.abbr,\n        sts.FL.abbr,\n        sts.GA.abbr,\n        sts.IL.abbr,\n        sts.IN.abbr,\n        sts.KS.abbr,\n        sts.KY.abbr,\n        sts.KY.abbr,\n        sts.MA.abbr,\n        sts.MD.abbr,\n        sts.ME.abbr,\n        sts.MI.abbr,\n        sts.MN.abbr,\n        sts.MO.abbr,\n        sts.MS.abbr,\n        sts.MT.abbr,\n        sts.NC.abbr,\n        sts.ND.abbr,\n        sts.NE.abbr,\n        sts.NH.abbr,\n        sts.NJ.abbr,\n        sts.NY.abbr,\n        sts.OH.abbr,\n        sts.OK.abbr,\n        sts.PA.abbr,\n        sts.RI.abbr,\n        sts.SD.abbr,\n        sts.TN.abbr,\n        sts.TX.abbr,\n        sts.UT.abbr,\n        sts.VA.abbr,\n        sts.VT.abbr,\n        sts.WI.abbr,\n    }\n\n    class HeaterEfficiencies(Enum):\n        \"\"\"Combination of system efficiency and distribution efficiency.\n\n        Note:\n            Numbers taken from https://www.efficiencymaine.com/at-home/heating-cost-comparison/\n        \"\"\"\n\n        HEAT_PUMP_GEOTHERMAL = 3.69\n        HEAT_PUMP_DUCTLESS = 2.7  # mini split\n        HEAT_PUMP_DUCTED = 2.16\n        BASEBOARD = 1\n        KEROSENE_ROOM_HEATER = 0.87\n        PROPANE_BOILER = 0.837\n        NG_BOILER = 0.828\n        NG_ROOM_HEATER = 0.81\n        PROPANE_ROOM_HEATER = 0.81\n        OIL_BOILER = 0.783\n        WOOD_STOVE = 0.75\n        PELLET_STOVE = 0.75\n        NG_FURNACE = 0.744  #! double check this value\n        PROPANE_FURNACE = 0.744\n        OIL_FURNACE = 0.704\n        PELLET_BOILER = 0.639\n\n    class EnergyType(Enum):\n        PROPANE = 1\n        HEATING_OIL = 2\n        NATURAL_GAS = 3\n        ELECTRICITY = 4\n\n    class PetroleumProductTypes(StrEnum):\n        NATURAL_GAS = \"EPG0\"\n        PROPANE = \"EPLLPA\"\n        HEATING_OIL = \"EPD2F\"\n\n    class FuelBTUConversion(Enum):\n        # https://www.edf.org/sites/default/files/10071_EDF_BottomBarrel_Ch3.pdf\n        # https://www.eia.gov/energyexplained/units-and-calculators/british-thermal-units.php\n        # https://www.eia.gov/energyexplained/units-and-calculators/\n        NO1_OIL_BTU_PER_GAL = 135_000\n        NO2_OIL_BTU_PER_GAL = 140_000\n        NO4_OIL_BTU_PER_GAL = 146_000\n        NO5_OIL_BTU_PER_GAL = 144_500\n        NO6_OIL_BTU_PER_GAL = 150_000\n        HEATING_OIL_BTU_PER_GAL = 138_500\n        ELECTRICITY_BTU_PER_KWH = 3_412.14\n        NG_BTU_PER_MCT = 1_036_000  # 1000 cubic feet of gas\n        NG_BTU_PER_THERM = 100_000\n        PROPANE_BTU_PER_GAL = 91_452\n        WOOD_BTU_PER_CORD = 20_000_000\n\n    def __init__(self):\n        self.eia_base_url = \"https://api.eia.gov/v2\"\n        self.api_key = os.getenv(\"EIA_API_KEY\")\n        if self.api_key is None:\n            log(\n                \"No Census API key found in a .env file in project directory. please request a key at https://www.eia.gov/opendata/register.php\",\n                \"critical\",\n            )\n            exit()\n\n    def price_per_mbtu_with_efficiency(\n        self, energy_price_dict: dict\n    ) -&gt; dict[str, str | EnergyType | float]:\n        \"\"\"Convert an energy source's price per quantity into price per BTU with an efficiency.\n\n        Note:\n            Efficiency data taken from https://portfoliomanager.energystar.gov/pdf/reference/Thermal%20Conversions.pdf\n\n        See also:\n            `EIADataRetriever.HeaterEfficiencies`\n\n        Args:\n            energy_price_dict (dict): energy source json\n\n        Returns:\n            dict: new dictionary with btu centric pricing\n        \"\"\"\n        #! make new function based on burner type/ end usage type\n        CENTS_IN_DOLLAR = 100\n        match energy_price_dict.get(\"type\"):\n            case self.EnergyType.PROPANE.value:\n                # for loop is done for every case since i dont want to use `eval` or parse a string of division to keep PEMDAS. this is why i dont have an efficiency func yet\n                for key, value in energy_price_dict.items():\n                    if (\n                        key in [\"type\", \"state\", None]\n                        or energy_price_dict.get(key) is None\n                    ):\n                        continue\n                    energy_price_dict[key] = (\n                        value\n                        / (\n                            self.FuelBTUConversion.PROPANE_BTU_PER_GAL.value\n                            * self.HeaterEfficiencies.PROPANE_FURNACE.value\n                        )\n                        * 1_000\n                    )\n            case self.EnergyType.NATURAL_GAS.value:\n                for key, value in energy_price_dict.items():\n                    if (\n                        key in [\"type\", \"state\", None]\n                        or energy_price_dict.get(key) is None\n                    ):\n                        continue\n                    energy_price_dict[key] = (\n                        value\n                        / (\n                            self.FuelBTUConversion.NG_BTU_PER_MCT.value\n                            * self.HeaterEfficiencies.NG_FURNACE.value\n                        )\n                        * 1_000\n                    )\n            case self.EnergyType.ELECTRICITY.value:\n                for key, value in energy_price_dict.items():\n                    if (\n                        key in [\"type\", \"state\", None]\n                        or energy_price_dict.get(key) is None\n                    ):\n                        continue\n                    energy_price_dict[key] = (\n                        value\n                        / CENTS_IN_DOLLAR\n                        / (\n                            self.FuelBTUConversion.ELECTRICITY_BTU_PER_KWH.value\n                            * self.HeaterEfficiencies.HEAT_PUMP_DUCTED.value\n                        )\n                        * 1_000\n                    )\n            case self.EnergyType.HEATING_OIL.value:\n                for key, value in energy_price_dict.items():\n                    if (\n                        key in [\"type\", \"state\", None]\n                        or energy_price_dict.get(key) is None\n                    ):\n                        continue\n                    energy_price_dict[key] = (\n                        value\n                        / (\n                            self.FuelBTUConversion.HEATING_OIL_BTU_PER_GAL.value\n                            * self.HeaterEfficiencies.OIL_BOILER.value\n                        )\n                        * 1_000\n                    )\n            case _:\n                log(\"Could not translate dict to btu per price.\", \"warn\")\n\n        return energy_price_dict\n\n    # api to dict handler Helpers\n    def price_dict_to_clean_dict(\n        self, eia_json: dict, energy_type: EnergyType, state: str\n    ) -&gt; dict[str, str | EnergyType | float]:\n        \"\"\"Clean JSON data returned by EIA's API.\n\n        Args:\n            eia_json (dict): the response JSON\n            energy_type (EnergyType): the energy type\n            state (str): the state\n\n        Returns:\n            dict[str, str | EnergyType | float]: cleaned JSON\n        \"\"\"\n        # price key is different for electricity\n        accessor = \"value\"\n        if \"product\" not in eia_json[\"response\"][\"data\"][0]:\n            accessor = \"price\"\n\n        result_dict = {\n            entry[\"period\"]: entry[f\"{accessor}\"]\n            for entry in eia_json[\"response\"][\"data\"]\n        }\n        result_dict[\"type\"] = energy_type.value\n        result_dict[\"state\"] = state\n\n        return result_dict\n\n    def price_df_to_clean_dict(\n        self, eia_df: pl.DataFrame, energy_type: EnergyType, state: str\n    ) -&gt; dict[str, str | EnergyType | float]:\n        \"\"\"Clean DataFrame data consisting of EIA API data.\n\n        Args:\n            eia_df (pl.DataFrame): the DataFrame to clean\n            energy_type (EnergyType): the energy type\n            state (str): the state\n\n        Returns:\n            dict[str, str|EnergyType|float]: the dict\n        \"\"\"\n        result_dict = {}\n        for row in eia_df.rows(named=True):\n            year_month = f\"{row.get(\"year\")}-{row.get(\"month\"):02}\"\n            if row.get(\"monthly_avg_price\") is not None:\n                result_dict[year_month] = round(row.get(\"monthly_avg_price\"), 3)  # type: ignore\n        result_dict[\"type\"] = energy_type.value\n        result_dict[\"state\"] = state\n        return result_dict\n\n    # api to dict handler\n    def price_to_clean_dict(\n        self, price_struct: dict | pl.DataFrame, energy_type: EnergyType, state: str\n    ) -&gt; dict[str, str | EnergyType | float]:\n        \"\"\"Handle the different data types that EIA data could be stored in.\n\n        Args:\n            price_struct (dict | pl.DataFrame): a data structure containing the year, month, and price info\n            energy_type (EnergyType): the energy type\n            state (str): the state\n\n        Raises:\n            TypeError: raised if the type of `price_struct` is not supported\n\n        Returns:\n            dict[str, str|EnergyType|float]: the normalized and structured data in dict form\n        \"\"\"\n        match price_struct:\n            case dict():\n                return self.price_dict_to_clean_dict(price_struct, energy_type, state)\n            case pl.DataFrame():\n                return self.price_df_to_clean_dict(price_struct, energy_type, state)\n            case _:\n                raise TypeError(f\"Type not supported: {type(energy_type)}\")\n\n    # api interaction\n    def monthly_electricity_price_per_kwh(\n        self, state: str, start_date: datetime.date, end_date: datetime.date\n    ) -&gt; dict[str, Any]:\n        \"\"\"Get a state's average monthly energy price.\n\n        Note:\n            Data is returned in cents/KWh.\n\n        Args:\n            state (str): the 2 character postal code of a state\n            start_date (datetime.date): the start date, inclusive\n            end_date (datetime.date): the end date, non inclusive\n\n        Returns:\n            dict: the dictionary in `year-month: price` form\n        \"\"\"\n        url = f\"{self.eia_base_url}/electricity/retail-sales/data/?frequency=monthly&amp;data[0]=price&amp;facets[stateid][]={state}&amp;facets[sectorid][]=RES&amp;start={start_date.year}-{start_date.month:02}&amp;end={end_date.year}-{end_date.month:02}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n        eia_request = req_get_wrapper(url)\n        eia_request.raise_for_status()\n\n        return eia_request.json()\n\n    def monthly_ng_price_per_mcf(\n        self, state: str, start_date: datetime.date, end_date: datetime.date\n    ) -&gt; dict[str, Any]:\n        \"\"\"Get a state's average natural gas price.\n\n        Note:\n            Data is returned in dollars per mega cubic feet.\n\n        Args:\n            state (str): the 2 character postal code of a state\n            start_date (datetime.date): the start date, inclusive\n            end_date (datetime.date): the end date, non inclusive\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        # $/mcf\n        url = f\"https://api.eia.gov/v2/natural-gas/pri/sum/data/?frequency=monthly&amp;data[0]=value&amp;facets[duoarea][]=S{state}&amp;facets[process][]=PRS&amp;start={start_date.year}-{start_date.month:02}&amp;end={end_date.year}-{end_date.month:02}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n        eia_request = req_get_wrapper(url)\n        eia_request.raise_for_status()\n\n        return eia_request.json()\n\n    def monthly_heating_season_heating_oil_price_per_gal(\n        self, state: str, start_date: datetime.date, end_date: datetime.date\n    ) -&gt; pl.DataFrame:\n        \"\"\"Get a state's average heating oil price.\n\n        Note:\n            Data returned is in dollars per gallon.\n\n            Only these states are tracked, and only for the months October through March:\n                * CT\n                * DC\n                * DE\n                * IA\n                * IL\n                * IN\n                * KS\n                * KY\n                * MA\n                * MD\n                * ME\n                * MI\n                * MN\n                * MO\n                * NC\n                * ND\n                * NE\n                * NH\n                * NJ\n                * NY\n                * OH\n                * PA\n                * RI\n                * SD\n                * VA\n                * VT\n                * WI\n        Args:\n            state (str): 2 char postal code\n            start_date (datetime.date): the start date, inclusive\n            end_date (datetime.date): the end date, non inclusive\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        # heating season is Oct - march, $/gal\n        url = f\"https://api.eia.gov/v2/petroleum/pri/wfr/data/?frequency=weekly&amp;data[0]=value&amp;facets[duoarea][]=S{state}&amp;facets[product][]=EPD2F&amp;start={start_date}&amp;end={end_date}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n        eia_request = req_get_wrapper(url)\n        eia_request.raise_for_status()\n\n        json = eia_request.json()\n        df = pl.DataFrame(json[\"response\"][\"data\"])\n        # becomes int, so months are sig figs\n        df = df.with_columns(pl.col(\"period\").str.strptime(pl.Date))\n        df = df.with_columns(\n            pl.col(\"period\").dt.year().alias(\"year\"),\n            pl.col(\"period\").dt.month().alias(\"month\"),\n        )\n\n        monthly_avg_price = (\n            df.group_by([\"year\", \"month\"])\n            .agg(pl.col(\"value\").mean().alias(\"monthly_avg_price\"))\n            .sort(\"year\", \"month\")\n        )\n\n        return monthly_avg_price\n\n    def monthly_heating_season_propane_price_per_gal(\n        self, state: str, start_date: datetime.date, end_date: datetime.date\n    ) -&gt; pl.DataFrame:\n        \"\"\"Get a state's average propane price in dollars per gal.\n\n        Note:\n            Only these states are tracked, and only for the months October through Marc:\n                * AL\n                * AR\n                * CO\n                * CT\n                * DE\n                * FL\n                * GA\n                * IL\n                * IN\n                * KS\n                * KY\n                * KY\n                * MA\n                * MD\n                * ME\n                * MI\n                * MN\n                * MO\n                * MS\n                * MT\n                * NC\n                * ND\n                * NE\n                * NH\n                * NJ\n                * NY\n                * OH\n                * OK\n                * PA\n                * RI\n                * SD\n                * TN\n                * TX\n                * UT\n                * VA\n                * VT\n                * WI\n\n        Args:\n            state (str): 2 character postal code\n            start_date (datetime.date): the start date, inclusive\n            end_date (datetime.date): the end date, non inclusive\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        # heating season is Oct - march, $/gal\n        url = f\"https://api.eia.gov/v2/petroleum/pri/wfr/data/?frequency=weekly&amp;data[0]=value&amp;facets[process][]=PRS&amp;facets[duoarea][]=S{state}&amp;facets[product][]=EPLLPA&amp;start={start_date}&amp;end={end_date}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n        eia_request = req_get_wrapper(url)\n        eia_request.raise_for_status()\n\n        json = eia_request.json()\n        # return self.price_json_to_dict(eia_request.json())\n        df = pl.DataFrame(json[\"response\"][\"data\"])\n        # df = df.with_columns(pl.col(\"period\").str.to_date().alias(\"period\"))\n        df = df.with_columns(pl.col(\"period\").str.strptime(pl.Date))\n        df = df.with_columns(\n            pl.col(\"period\").dt.year().alias(\"year\"),\n            pl.col(\"period\").dt.month().alias(\"month\"),\n        )\n\n        monthly_avg_price = (\n            df.group_by([\"year\", \"month\"])\n            .agg(pl.col(\"value\").mean().alias(\"monthly_avg_price\"))\n            .sort(\"year\", \"month\")\n        )\n\n        return monthly_avg_price\n\n    def monthly_price_per_mbtu_by_energy_type(\n        self,\n        energy_type: EnergyType,\n        state: str,\n        start_date: datetime.date,\n        end_date: datetime.date,\n    ) -&gt; dict[str, str | EnergyType | float]:\n        \"\"\"Get the cost per MBTU for the given energy type for the state, over the given period of time. Refer to EIA's documentation\n        for changes to data collection during certain years.\n\n        Args:\n            energy_type (EnergyType): The energy type\n            state (str): the 2 character postal abbreviation. Note that for heating oil, only certain states have this information collected\n            start_date (datetime.date): the date for which to start the search. Inclusive. Not that for heating oil, only heating months will be returned\n            end_date (datetime.date): the date for which to end the search. Non inclusive\n\n        Raises:\n            NotImplementedError: Invalid energy type\n\n        Returns:\n            dict: year-month: price in USD to BTU\n        \"\"\"\n        if len(state) &gt; 2:\n            state = sts.lookup(state).abbr  # type: ignore\n        match energy_type:\n            case self.EnergyType.PROPANE:\n                return self.price_per_mbtu_with_efficiency(\n                    self.price_to_clean_dict(\n                        self.monthly_heating_season_propane_price_per_gal(\n                            state, start_date, end_date\n                        ),\n                        energy_type,\n                        state,\n                    )\n                )\n            case self.EnergyType.NATURAL_GAS:\n                return self.price_per_mbtu_with_efficiency(\n                    self.price_to_clean_dict(\n                        self.monthly_ng_price_per_mcf(state, start_date, end_date),\n                        energy_type,\n                        state,\n                    )\n                )\n            case self.EnergyType.ELECTRICITY:\n                return self.price_per_mbtu_with_efficiency(\n                    self.price_to_clean_dict(\n                        self.monthly_electricity_price_per_kwh(\n                            state, start_date, end_date\n                        ),\n                        energy_type,\n                        state,\n                    )\n                )\n            case self.EnergyType.HEATING_OIL:\n                return self.price_per_mbtu_with_efficiency(\n                    self.price_to_clean_dict(\n                        self.monthly_heating_season_heating_oil_price_per_gal(\n                            state, start_date, end_date\n                        ),\n                        energy_type,\n                        state,\n                    )\n                )\n            case _:\n                raise NotImplementedError(f\"Unsupported energy type: {energy_type}\")\n\n    def monthly_price_per_mbtu_by_energy_type_by_state(\n        self, state: str, start_date: datetime.date, end_date: datetime.date\n    ) -&gt; list[Any]:\n        \"\"\"Get all available energy prices per MBTU, taking efficiency into account, for a state.\n\n        Note:\n            Please keep times to within a year. For the non oil and propane, you have to go a month past.\n\n        Args:\n            state (str): 2 character postal code\n            start_date (datetime.date): start date\n            end_date (datetime.date): end date\n\n        Returns:\n            list[Any]: list of price dicts for available energy types for a state\n        \"\"\"\n        if len(state) &gt; 2:\n            state = sts.lookup(state).abbr  # type: ignore\n\n        dicts_to_return = []\n        if state in self.HEATING_OIL_STATES_ABBR:\n            dicts_to_return.append(\n                self.monthly_price_per_mbtu_by_energy_type(\n                    self.EnergyType.HEATING_OIL, state, start_date, end_date\n                )\n            )\n        if state in self.PROPANE_STATES_ABBR:\n            dicts_to_return.append(\n                self.monthly_price_per_mbtu_by_energy_type(\n                    self.EnergyType.PROPANE, state, start_date, end_date\n                )\n            )\n        dicts_to_return.append(\n            self.monthly_price_per_mbtu_by_energy_type(\n                self.EnergyType.NATURAL_GAS, state, start_date, end_date\n            )\n        )\n        dicts_to_return.append(\n            self.monthly_price_per_mbtu_by_energy_type(\n                self.EnergyType.ELECTRICITY, state, start_date, end_date\n            )\n        )\n        log(f\"{dicts_to_return = }\", \"debug\")\n        return dicts_to_return\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.HeaterEfficiencies","title":"<code>HeaterEfficiencies</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Combination of system efficiency and distribution efficiency.</p> Note <p>Numbers taken from https://www.efficiencymaine.com/at-home/heating-cost-comparison/</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>class HeaterEfficiencies(Enum):\n    \"\"\"Combination of system efficiency and distribution efficiency.\n\n    Note:\n        Numbers taken from https://www.efficiencymaine.com/at-home/heating-cost-comparison/\n    \"\"\"\n\n    HEAT_PUMP_GEOTHERMAL = 3.69\n    HEAT_PUMP_DUCTLESS = 2.7  # mini split\n    HEAT_PUMP_DUCTED = 2.16\n    BASEBOARD = 1\n    KEROSENE_ROOM_HEATER = 0.87\n    PROPANE_BOILER = 0.837\n    NG_BOILER = 0.828\n    NG_ROOM_HEATER = 0.81\n    PROPANE_ROOM_HEATER = 0.81\n    OIL_BOILER = 0.783\n    WOOD_STOVE = 0.75\n    PELLET_STOVE = 0.75\n    NG_FURNACE = 0.744  #! double check this value\n    PROPANE_FURNACE = 0.744\n    OIL_FURNACE = 0.704\n    PELLET_BOILER = 0.639\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.monthly_electricity_price_per_kwh","title":"<code>monthly_electricity_price_per_kwh(state, start_date, end_date)</code>","text":"<p>Get a state's average monthly energy price.</p> Note <p>Data is returned in cents/KWh.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>the 2 character postal code of a state</p> required <code>start_date</code> <code>date</code> <p>the start date, inclusive</p> required <code>end_date</code> <code>date</code> <p>the end date, non inclusive</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>the dictionary in <code>year-month: price</code> form</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def monthly_electricity_price_per_kwh(\n    self, state: str, start_date: datetime.date, end_date: datetime.date\n) -&gt; dict[str, Any]:\n    \"\"\"Get a state's average monthly energy price.\n\n    Note:\n        Data is returned in cents/KWh.\n\n    Args:\n        state (str): the 2 character postal code of a state\n        start_date (datetime.date): the start date, inclusive\n        end_date (datetime.date): the end date, non inclusive\n\n    Returns:\n        dict: the dictionary in `year-month: price` form\n    \"\"\"\n    url = f\"{self.eia_base_url}/electricity/retail-sales/data/?frequency=monthly&amp;data[0]=price&amp;facets[stateid][]={state}&amp;facets[sectorid][]=RES&amp;start={start_date.year}-{start_date.month:02}&amp;end={end_date.year}-{end_date.month:02}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n    eia_request = req_get_wrapper(url)\n    eia_request.raise_for_status()\n\n    return eia_request.json()\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.monthly_heating_season_heating_oil_price_per_gal","title":"<code>monthly_heating_season_heating_oil_price_per_gal(state, start_date, end_date)</code>","text":"<p>Get a state's average heating oil price.</p> Note <p>Data returned is in dollars per gallon.</p> <p>Only these states are tracked, and only for the months October through March:     * CT     * DC     * DE     * IA     * IL     * IN     * KS     * KY     * MA     * MD     * ME     * MI     * MN     * MO     * NC     * ND     * NE     * NH     * NJ     * NY     * OH     * PA     * RI     * SD     * VA     * VT     * WI</p> <p>Args:     state (str): 2 char postal code     start_date (datetime.date): the start date, inclusive     end_date (datetime.date): the end date, non inclusive</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>DataFrame</code> <p>description</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def monthly_heating_season_heating_oil_price_per_gal(\n    self, state: str, start_date: datetime.date, end_date: datetime.date\n) -&gt; pl.DataFrame:\n    \"\"\"Get a state's average heating oil price.\n\n    Note:\n        Data returned is in dollars per gallon.\n\n        Only these states are tracked, and only for the months October through March:\n            * CT\n            * DC\n            * DE\n            * IA\n            * IL\n            * IN\n            * KS\n            * KY\n            * MA\n            * MD\n            * ME\n            * MI\n            * MN\n            * MO\n            * NC\n            * ND\n            * NE\n            * NH\n            * NJ\n            * NY\n            * OH\n            * PA\n            * RI\n            * SD\n            * VA\n            * VT\n            * WI\n    Args:\n        state (str): 2 char postal code\n        start_date (datetime.date): the start date, inclusive\n        end_date (datetime.date): the end date, non inclusive\n\n    Returns:\n        dict: _description_\n    \"\"\"\n    # heating season is Oct - march, $/gal\n    url = f\"https://api.eia.gov/v2/petroleum/pri/wfr/data/?frequency=weekly&amp;data[0]=value&amp;facets[duoarea][]=S{state}&amp;facets[product][]=EPD2F&amp;start={start_date}&amp;end={end_date}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n    eia_request = req_get_wrapper(url)\n    eia_request.raise_for_status()\n\n    json = eia_request.json()\n    df = pl.DataFrame(json[\"response\"][\"data\"])\n    # becomes int, so months are sig figs\n    df = df.with_columns(pl.col(\"period\").str.strptime(pl.Date))\n    df = df.with_columns(\n        pl.col(\"period\").dt.year().alias(\"year\"),\n        pl.col(\"period\").dt.month().alias(\"month\"),\n    )\n\n    monthly_avg_price = (\n        df.group_by([\"year\", \"month\"])\n        .agg(pl.col(\"value\").mean().alias(\"monthly_avg_price\"))\n        .sort(\"year\", \"month\")\n    )\n\n    return monthly_avg_price\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.monthly_heating_season_propane_price_per_gal","title":"<code>monthly_heating_season_propane_price_per_gal(state, start_date, end_date)</code>","text":"<p>Get a state's average propane price in dollars per gal.</p> Note <p>Only these states are tracked, and only for the months October through Marc:     * AL     * AR     * CO     * CT     * DE     * FL     * GA     * IL     * IN     * KS     * KY     * KY     * MA     * MD     * ME     * MI     * MN     * MO     * MS     * MT     * NC     * ND     * NE     * NH     * NJ     * NY     * OH     * OK     * PA     * RI     * SD     * TN     * TX     * UT     * VA     * VT     * WI</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>2 character postal code</p> required <code>start_date</code> <code>date</code> <p>the start date, inclusive</p> required <code>end_date</code> <code>date</code> <p>the end date, non inclusive</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>DataFrame</code> <p>description</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def monthly_heating_season_propane_price_per_gal(\n    self, state: str, start_date: datetime.date, end_date: datetime.date\n) -&gt; pl.DataFrame:\n    \"\"\"Get a state's average propane price in dollars per gal.\n\n    Note:\n        Only these states are tracked, and only for the months October through Marc:\n            * AL\n            * AR\n            * CO\n            * CT\n            * DE\n            * FL\n            * GA\n            * IL\n            * IN\n            * KS\n            * KY\n            * KY\n            * MA\n            * MD\n            * ME\n            * MI\n            * MN\n            * MO\n            * MS\n            * MT\n            * NC\n            * ND\n            * NE\n            * NH\n            * NJ\n            * NY\n            * OH\n            * OK\n            * PA\n            * RI\n            * SD\n            * TN\n            * TX\n            * UT\n            * VA\n            * VT\n            * WI\n\n    Args:\n        state (str): 2 character postal code\n        start_date (datetime.date): the start date, inclusive\n        end_date (datetime.date): the end date, non inclusive\n\n    Returns:\n        dict: _description_\n    \"\"\"\n    # heating season is Oct - march, $/gal\n    url = f\"https://api.eia.gov/v2/petroleum/pri/wfr/data/?frequency=weekly&amp;data[0]=value&amp;facets[process][]=PRS&amp;facets[duoarea][]=S{state}&amp;facets[product][]=EPLLPA&amp;start={start_date}&amp;end={end_date}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n    eia_request = req_get_wrapper(url)\n    eia_request.raise_for_status()\n\n    json = eia_request.json()\n    # return self.price_json_to_dict(eia_request.json())\n    df = pl.DataFrame(json[\"response\"][\"data\"])\n    # df = df.with_columns(pl.col(\"period\").str.to_date().alias(\"period\"))\n    df = df.with_columns(pl.col(\"period\").str.strptime(pl.Date))\n    df = df.with_columns(\n        pl.col(\"period\").dt.year().alias(\"year\"),\n        pl.col(\"period\").dt.month().alias(\"month\"),\n    )\n\n    monthly_avg_price = (\n        df.group_by([\"year\", \"month\"])\n        .agg(pl.col(\"value\").mean().alias(\"monthly_avg_price\"))\n        .sort(\"year\", \"month\")\n    )\n\n    return monthly_avg_price\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.monthly_ng_price_per_mcf","title":"<code>monthly_ng_price_per_mcf(state, start_date, end_date)</code>","text":"<p>Get a state's average natural gas price.</p> Note <p>Data is returned in dollars per mega cubic feet.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>the 2 character postal code of a state</p> required <code>start_date</code> <code>date</code> <p>the start date, inclusive</p> required <code>end_date</code> <code>date</code> <p>the end date, non inclusive</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>description</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def monthly_ng_price_per_mcf(\n    self, state: str, start_date: datetime.date, end_date: datetime.date\n) -&gt; dict[str, Any]:\n    \"\"\"Get a state's average natural gas price.\n\n    Note:\n        Data is returned in dollars per mega cubic feet.\n\n    Args:\n        state (str): the 2 character postal code of a state\n        start_date (datetime.date): the start date, inclusive\n        end_date (datetime.date): the end date, non inclusive\n\n    Returns:\n        dict: _description_\n    \"\"\"\n    # $/mcf\n    url = f\"https://api.eia.gov/v2/natural-gas/pri/sum/data/?frequency=monthly&amp;data[0]=value&amp;facets[duoarea][]=S{state}&amp;facets[process][]=PRS&amp;start={start_date.year}-{start_date.month:02}&amp;end={end_date.year}-{end_date.month:02}&amp;sort[0][column]=period&amp;sort[0][direction]=asc&amp;api_key={self.api_key}\"\n\n    eia_request = req_get_wrapper(url)\n    eia_request.raise_for_status()\n\n    return eia_request.json()\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.monthly_price_per_mbtu_by_energy_type","title":"<code>monthly_price_per_mbtu_by_energy_type(energy_type, state, start_date, end_date)</code>","text":"<p>Get the cost per MBTU for the given energy type for the state, over the given period of time. Refer to EIA's documentation for changes to data collection during certain years.</p> <p>Parameters:</p> Name Type Description Default <code>energy_type</code> <code>EnergyType</code> <p>The energy type</p> required <code>state</code> <code>str</code> <p>the 2 character postal abbreviation. Note that for heating oil, only certain states have this information collected</p> required <code>start_date</code> <code>date</code> <p>the date for which to start the search. Inclusive. Not that for heating oil, only heating months will be returned</p> required <code>end_date</code> <code>date</code> <p>the date for which to end the search. Non inclusive</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Invalid energy type</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str | EnergyType | float]</code> <p>year-month: price in USD to BTU</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def monthly_price_per_mbtu_by_energy_type(\n    self,\n    energy_type: EnergyType,\n    state: str,\n    start_date: datetime.date,\n    end_date: datetime.date,\n) -&gt; dict[str, str | EnergyType | float]:\n    \"\"\"Get the cost per MBTU for the given energy type for the state, over the given period of time. Refer to EIA's documentation\n    for changes to data collection during certain years.\n\n    Args:\n        energy_type (EnergyType): The energy type\n        state (str): the 2 character postal abbreviation. Note that for heating oil, only certain states have this information collected\n        start_date (datetime.date): the date for which to start the search. Inclusive. Not that for heating oil, only heating months will be returned\n        end_date (datetime.date): the date for which to end the search. Non inclusive\n\n    Raises:\n        NotImplementedError: Invalid energy type\n\n    Returns:\n        dict: year-month: price in USD to BTU\n    \"\"\"\n    if len(state) &gt; 2:\n        state = sts.lookup(state).abbr  # type: ignore\n    match energy_type:\n        case self.EnergyType.PROPANE:\n            return self.price_per_mbtu_with_efficiency(\n                self.price_to_clean_dict(\n                    self.monthly_heating_season_propane_price_per_gal(\n                        state, start_date, end_date\n                    ),\n                    energy_type,\n                    state,\n                )\n            )\n        case self.EnergyType.NATURAL_GAS:\n            return self.price_per_mbtu_with_efficiency(\n                self.price_to_clean_dict(\n                    self.monthly_ng_price_per_mcf(state, start_date, end_date),\n                    energy_type,\n                    state,\n                )\n            )\n        case self.EnergyType.ELECTRICITY:\n            return self.price_per_mbtu_with_efficiency(\n                self.price_to_clean_dict(\n                    self.monthly_electricity_price_per_kwh(\n                        state, start_date, end_date\n                    ),\n                    energy_type,\n                    state,\n                )\n            )\n        case self.EnergyType.HEATING_OIL:\n            return self.price_per_mbtu_with_efficiency(\n                self.price_to_clean_dict(\n                    self.monthly_heating_season_heating_oil_price_per_gal(\n                        state, start_date, end_date\n                    ),\n                    energy_type,\n                    state,\n                )\n            )\n        case _:\n            raise NotImplementedError(f\"Unsupported energy type: {energy_type}\")\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.monthly_price_per_mbtu_by_energy_type_by_state","title":"<code>monthly_price_per_mbtu_by_energy_type_by_state(state, start_date, end_date)</code>","text":"<p>Get all available energy prices per MBTU, taking efficiency into account, for a state.</p> Note <p>Please keep times to within a year. For the non oil and propane, you have to go a month past.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>2 character postal code</p> required <code>start_date</code> <code>date</code> <p>start date</p> required <code>end_date</code> <code>date</code> <p>end date</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>list[Any]: list of price dicts for available energy types for a state</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def monthly_price_per_mbtu_by_energy_type_by_state(\n    self, state: str, start_date: datetime.date, end_date: datetime.date\n) -&gt; list[Any]:\n    \"\"\"Get all available energy prices per MBTU, taking efficiency into account, for a state.\n\n    Note:\n        Please keep times to within a year. For the non oil and propane, you have to go a month past.\n\n    Args:\n        state (str): 2 character postal code\n        start_date (datetime.date): start date\n        end_date (datetime.date): end date\n\n    Returns:\n        list[Any]: list of price dicts for available energy types for a state\n    \"\"\"\n    if len(state) &gt; 2:\n        state = sts.lookup(state).abbr  # type: ignore\n\n    dicts_to_return = []\n    if state in self.HEATING_OIL_STATES_ABBR:\n        dicts_to_return.append(\n            self.monthly_price_per_mbtu_by_energy_type(\n                self.EnergyType.HEATING_OIL, state, start_date, end_date\n            )\n        )\n    if state in self.PROPANE_STATES_ABBR:\n        dicts_to_return.append(\n            self.monthly_price_per_mbtu_by_energy_type(\n                self.EnergyType.PROPANE, state, start_date, end_date\n            )\n        )\n    dicts_to_return.append(\n        self.monthly_price_per_mbtu_by_energy_type(\n            self.EnergyType.NATURAL_GAS, state, start_date, end_date\n        )\n    )\n    dicts_to_return.append(\n        self.monthly_price_per_mbtu_by_energy_type(\n            self.EnergyType.ELECTRICITY, state, start_date, end_date\n        )\n    )\n    log(f\"{dicts_to_return = }\", \"debug\")\n    return dicts_to_return\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.price_df_to_clean_dict","title":"<code>price_df_to_clean_dict(eia_df, energy_type, state)</code>","text":"<p>Clean DataFrame data consisting of EIA API data.</p> <p>Parameters:</p> Name Type Description Default <code>eia_df</code> <code>DataFrame</code> <p>the DataFrame to clean</p> required <code>energy_type</code> <code>EnergyType</code> <p>the energy type</p> required <code>state</code> <code>str</code> <p>the state</p> required <p>Returns:</p> Type Description <code>dict[str, str | EnergyType | float]</code> <p>dict[str, str|EnergyType|float]: the dict</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def price_df_to_clean_dict(\n    self, eia_df: pl.DataFrame, energy_type: EnergyType, state: str\n) -&gt; dict[str, str | EnergyType | float]:\n    \"\"\"Clean DataFrame data consisting of EIA API data.\n\n    Args:\n        eia_df (pl.DataFrame): the DataFrame to clean\n        energy_type (EnergyType): the energy type\n        state (str): the state\n\n    Returns:\n        dict[str, str|EnergyType|float]: the dict\n    \"\"\"\n    result_dict = {}\n    for row in eia_df.rows(named=True):\n        year_month = f\"{row.get(\"year\")}-{row.get(\"month\"):02}\"\n        if row.get(\"monthly_avg_price\") is not None:\n            result_dict[year_month] = round(row.get(\"monthly_avg_price\"), 3)  # type: ignore\n    result_dict[\"type\"] = energy_type.value\n    result_dict[\"state\"] = state\n    return result_dict\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.price_dict_to_clean_dict","title":"<code>price_dict_to_clean_dict(eia_json, energy_type, state)</code>","text":"<p>Clean JSON data returned by EIA's API.</p> <p>Parameters:</p> Name Type Description Default <code>eia_json</code> <code>dict</code> <p>the response JSON</p> required <code>energy_type</code> <code>EnergyType</code> <p>the energy type</p> required <code>state</code> <code>str</code> <p>the state</p> required <p>Returns:</p> Type Description <code>dict[str, str | EnergyType | float]</code> <p>dict[str, str | EnergyType | float]: cleaned JSON</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def price_dict_to_clean_dict(\n    self, eia_json: dict, energy_type: EnergyType, state: str\n) -&gt; dict[str, str | EnergyType | float]:\n    \"\"\"Clean JSON data returned by EIA's API.\n\n    Args:\n        eia_json (dict): the response JSON\n        energy_type (EnergyType): the energy type\n        state (str): the state\n\n    Returns:\n        dict[str, str | EnergyType | float]: cleaned JSON\n    \"\"\"\n    # price key is different for electricity\n    accessor = \"value\"\n    if \"product\" not in eia_json[\"response\"][\"data\"][0]:\n        accessor = \"price\"\n\n    result_dict = {\n        entry[\"period\"]: entry[f\"{accessor}\"]\n        for entry in eia_json[\"response\"][\"data\"]\n    }\n    result_dict[\"type\"] = energy_type.value\n    result_dict[\"state\"] = state\n\n    return result_dict\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.price_per_mbtu_with_efficiency","title":"<code>price_per_mbtu_with_efficiency(energy_price_dict)</code>","text":"<p>Convert an energy source's price per quantity into price per BTU with an efficiency.</p> Note <p>Efficiency data taken from https://portfoliomanager.energystar.gov/pdf/reference/Thermal%20Conversions.pdf</p> See also <p><code>EIADataRetriever.HeaterEfficiencies</code></p> <p>Parameters:</p> Name Type Description Default <code>energy_price_dict</code> <code>dict</code> <p>energy source json</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str | EnergyType | float]</code> <p>new dictionary with btu centric pricing</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def price_per_mbtu_with_efficiency(\n    self, energy_price_dict: dict\n) -&gt; dict[str, str | EnergyType | float]:\n    \"\"\"Convert an energy source's price per quantity into price per BTU with an efficiency.\n\n    Note:\n        Efficiency data taken from https://portfoliomanager.energystar.gov/pdf/reference/Thermal%20Conversions.pdf\n\n    See also:\n        `EIADataRetriever.HeaterEfficiencies`\n\n    Args:\n        energy_price_dict (dict): energy source json\n\n    Returns:\n        dict: new dictionary with btu centric pricing\n    \"\"\"\n    #! make new function based on burner type/ end usage type\n    CENTS_IN_DOLLAR = 100\n    match energy_price_dict.get(\"type\"):\n        case self.EnergyType.PROPANE.value:\n            # for loop is done for every case since i dont want to use `eval` or parse a string of division to keep PEMDAS. this is why i dont have an efficiency func yet\n            for key, value in energy_price_dict.items():\n                if (\n                    key in [\"type\", \"state\", None]\n                    or energy_price_dict.get(key) is None\n                ):\n                    continue\n                energy_price_dict[key] = (\n                    value\n                    / (\n                        self.FuelBTUConversion.PROPANE_BTU_PER_GAL.value\n                        * self.HeaterEfficiencies.PROPANE_FURNACE.value\n                    )\n                    * 1_000\n                )\n        case self.EnergyType.NATURAL_GAS.value:\n            for key, value in energy_price_dict.items():\n                if (\n                    key in [\"type\", \"state\", None]\n                    or energy_price_dict.get(key) is None\n                ):\n                    continue\n                energy_price_dict[key] = (\n                    value\n                    / (\n                        self.FuelBTUConversion.NG_BTU_PER_MCT.value\n                        * self.HeaterEfficiencies.NG_FURNACE.value\n                    )\n                    * 1_000\n                )\n        case self.EnergyType.ELECTRICITY.value:\n            for key, value in energy_price_dict.items():\n                if (\n                    key in [\"type\", \"state\", None]\n                    or energy_price_dict.get(key) is None\n                ):\n                    continue\n                energy_price_dict[key] = (\n                    value\n                    / CENTS_IN_DOLLAR\n                    / (\n                        self.FuelBTUConversion.ELECTRICITY_BTU_PER_KWH.value\n                        * self.HeaterEfficiencies.HEAT_PUMP_DUCTED.value\n                    )\n                    * 1_000\n                )\n        case self.EnergyType.HEATING_OIL.value:\n            for key, value in energy_price_dict.items():\n                if (\n                    key in [\"type\", \"state\", None]\n                    or energy_price_dict.get(key) is None\n                ):\n                    continue\n                energy_price_dict[key] = (\n                    value\n                    / (\n                        self.FuelBTUConversion.HEATING_OIL_BTU_PER_GAL.value\n                        * self.HeaterEfficiencies.OIL_BOILER.value\n                    )\n                    * 1_000\n                )\n        case _:\n            log(\"Could not translate dict to btu per price.\", \"warn\")\n\n    return energy_price_dict\n</code></pre>"},{"location":"backend/secondarydata/#backend.secondarydata.EIADataRetriever.price_to_clean_dict","title":"<code>price_to_clean_dict(price_struct, energy_type, state)</code>","text":"<p>Handle the different data types that EIA data could be stored in.</p> <p>Parameters:</p> Name Type Description Default <code>price_struct</code> <code>dict | DataFrame</code> <p>a data structure containing the year, month, and price info</p> required <code>energy_type</code> <code>EnergyType</code> <p>the energy type</p> required <code>state</code> <code>str</code> <p>the state</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>raised if the type of <code>price_struct</code> is not supported</p> <p>Returns:</p> Type Description <code>dict[str, str | EnergyType | float]</code> <p>dict[str, str|EnergyType|float]: the normalized and structured data in dict form</p> Source code in <code>src\\backend\\secondarydata.py</code> <pre><code>def price_to_clean_dict(\n    self, price_struct: dict | pl.DataFrame, energy_type: EnergyType, state: str\n) -&gt; dict[str, str | EnergyType | float]:\n    \"\"\"Handle the different data types that EIA data could be stored in.\n\n    Args:\n        price_struct (dict | pl.DataFrame): a data structure containing the year, month, and price info\n        energy_type (EnergyType): the energy type\n        state (str): the state\n\n    Raises:\n        TypeError: raised if the type of `price_struct` is not supported\n\n    Returns:\n        dict[str, str|EnergyType|float]: the normalized and structured data in dict form\n    \"\"\"\n    match price_struct:\n        case dict():\n            return self.price_dict_to_clean_dict(price_struct, energy_type, state)\n        case pl.DataFrame():\n            return self.price_df_to_clean_dict(price_struct, energy_type, state)\n        case _:\n            raise TypeError(f\"Type not supported: {type(energy_type)}\")\n</code></pre>"},{"location":"backend/us/states/","title":"States","text":""},{"location":"backend/us/states/#backend.us.states.State","title":"<code>State</code>","text":"Source code in <code>src\\backend\\us\\states.py</code> <pre><code>class State:\n    abbr: str\n    ap_abbr: Optional[str]\n    capital: Optional[str]\n    capital_tz: Optional[str]\n    fips: Optional[str]\n    is_territory: bool\n    is_obsolete: bool\n    is_contiguous: bool\n    is_continental: bool\n    name: str\n    name_metaphone: str\n    statehood_year: Optional[int]\n    time_zones: List[str]\n\n    def __init__(self, **kwargs):\n        for k, v in kwargs.items():\n            setattr(self, k, v)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;State:{self.name}&gt;\"\n\n    def __str__(self) -&gt; str:\n        return self.name\n\n    def shapefile_urls(self) -&gt; Optional[Dict[str, str]]:\n        \"\"\"Shapefiles are available directly from the US Census Bureau:\n        https://www.census.gov/cgi-bin/geo/shapefiles/index.php\n        \"\"\"\n\n        fips = self.fips\n\n        if not fips:\n            return None\n\n        base = \"https://www2.census.gov/geo/tiger/TIGER2010/\"\n        urls = {\n            \"tract\": urljoin(base, f\"TRACT/2010/tl_2010_{fips}_tract10.zip\"),\n            \"cd\": urljoin(base, f\"CD/111/tl_2010_{fips}_cd111.zip\"),\n            \"county\": urljoin(base, f\"COUNTY/2010/tl_2010_{fips}_county10.zip\"),\n            \"state\": urljoin(base, f\"STATE/2010/tl_2010_{fips}_state10.zip\"),\n            \"zcta\": urljoin(base, f\"ZCTA5/2010/tl_2010_{fips}_zcta510.zip\"),\n            \"block\": urljoin(base, f\"TABBLOCK/2010/tl_2010_{fips}_tabblock10.zip\"),\n            \"blockgroup\": urljoin(base, f\"BG/2010/tl_2010_{fips}_bg10.zip\"),\n        }\n\n        return urls\n</code></pre>"},{"location":"backend/us/states/#backend.us.states.State.shapefile_urls","title":"<code>shapefile_urls()</code>","text":"<p>Shapefiles are available directly from the US Census Bureau: https://www.census.gov/cgi-bin/geo/shapefiles/index.php</p> Source code in <code>src\\backend\\us\\states.py</code> <pre><code>def shapefile_urls(self) -&gt; Optional[Dict[str, str]]:\n    \"\"\"Shapefiles are available directly from the US Census Bureau:\n    https://www.census.gov/cgi-bin/geo/shapefiles/index.php\n    \"\"\"\n\n    fips = self.fips\n\n    if not fips:\n        return None\n\n    base = \"https://www2.census.gov/geo/tiger/TIGER2010/\"\n    urls = {\n        \"tract\": urljoin(base, f\"TRACT/2010/tl_2010_{fips}_tract10.zip\"),\n        \"cd\": urljoin(base, f\"CD/111/tl_2010_{fips}_cd111.zip\"),\n        \"county\": urljoin(base, f\"COUNTY/2010/tl_2010_{fips}_county10.zip\"),\n        \"state\": urljoin(base, f\"STATE/2010/tl_2010_{fips}_state10.zip\"),\n        \"zcta\": urljoin(base, f\"ZCTA5/2010/tl_2010_{fips}_zcta510.zip\"),\n        \"block\": urljoin(base, f\"TABBLOCK/2010/tl_2010_{fips}_tabblock10.zip\"),\n        \"blockgroup\": urljoin(base, f\"BG/2010/tl_2010_{fips}_bg10.zip\"),\n    }\n\n    return urls\n</code></pre>"},{"location":"backend/us/states/#backend.us.states.lookup","title":"<code>lookup(val, field=None, use_cache=True)</code>","text":"<p>State lookup. This method will make a best effort attempt at finding the state based on the lookup value provided.</p> <ul> <li>two digits will search for FIPS code</li> <li>two letters will search for state abbreviation</li> </ul> <p>Exact matches can be done on any attribute on State objects by passing the <code>field</code> argument. This does an exact, case-sensitive comparison against the specified field.</p> <p>This method caches non-None results, but can the cache can be bypassed with the <code>use_cache=False</code> argument.</p> Source code in <code>src\\backend\\us\\states.py</code> <pre><code>def lookup(val, field: Optional[str] = None, use_cache: bool = True) -&gt; Optional[State]:\n    \"\"\"State lookup. This method will make a best effort\n    attempt at finding the state based on the lookup value provided.\n\n      * two digits will search for FIPS code\n      * two letters will search for state abbreviation\n\n    Exact matches can be done on any attribute on State objects by passing\n    the `field` argument. This does an exact, case-sensitive comparison against\n    the specified field.\n\n    This method caches non-None results, but can the cache can be bypassed\n    with the `use_cache=False` argument.\n    \"\"\"\n\n    matched_state = None\n\n    if field is None:\n        if FIPS_RE.match(val):\n            field = \"fips\"\n        elif ABBR_RE.match(val):\n            val = val.upper()\n            field = \"abbr\"\n        else:\n            val = val.title()\n            field = \"name\"\n\n    # see if result is in cache\n    cache_key = f\"{field}:{val}\"\n    if use_cache and cache_key in _lookup_cache:\n        matched_state = _lookup_cache[cache_key]\n\n    for state in STATES_AND_TERRITORIES:\n        if val == getattr(state, field):\n            matched_state = state\n            if use_cache:\n                _lookup_cache[cache_key] = state\n\n    return matched_state\n</code></pre>"},{"location":"backend/us/unitedstatesofamerica/","title":"Unitedstatesofamerica","text":""},{"location":"gui/app/","title":"App","text":""},{"location":"gui/datapage/","title":"Datapage","text":""},{"location":"gui/datapage/#gui.datapage.DataPage","title":"<code>DataPage</code>","text":"<p>             Bases: <code>CTkFrame</code></p> <p>Crate page for displaying energy data and links to censusreporter.org for census level data</p> Source code in <code>src\\gui\\datapage.py</code> <pre><code>class DataPage(ctk.CTkFrame):\n    \"\"\"Crate page for displaying energy data and links to censusreporter.org for census level data\"\"\"\n\n    def __init__(self, master, **kwargs):\n        super().__init__(master, **kwargs)\n        self.msa_name = None\n        self.income_df = None\n        self.demog_df = None\n        self.states_in_msa = None\n        self.state_demog_dfs = None\n        self.state_income_dfs = None\n        self.cur_year = datetime.datetime.now().year\n        self.years = [\n            str(self.cur_year),\n            str(self.cur_year - 1),\n            str(self.cur_year - 2),\n            str(self.cur_year - 3),\n            str(self.cur_year - 4),\n        ]\n        self.roboto_font = ctk.CTkFont(family=\"Roboto\")\n        self.roboto_header_font = ctk.CTkFont(family=\"Roboto\", size=28)\n        self.roboto_link_font = ctk.CTkFont(family=\"Roboto\", underline=True, size=20)\n        self.create_widgets()\n\n    def create_widgets(self) -&gt; None:\n        \"\"\"Create widgets.\"\"\"\n        # bug in sockets library wont allow you to raise keyboardinterrupt, so stopping\n        # Content frame will have 4 rows. first will be header, 2nd is energy graph, 3rd will contain a frame that has censusreport.org links, 4th will have progress bar frame\n        self.content_frame = ctk.CTkFrame(self, border_width=2)\n        self.content_banner_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n        self.state_and_year_content_banner_dropdown_frame = ctk.CTkFrame(\n            self.content_banner_frame, border_width=2\n        )\n        self.census_reporter_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n        self.log_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n\n        self.content_banner_main_text = ctk.CTkLabel(\n            self.content_banner_frame,\n            text=\"Census and Energy Data:\",\n            font=self.roboto_header_font,\n        )\n        self.content_banner_main_text.bind(\n            \"&lt;Configure&gt;\",\n            command=lambda x: self.content_banner_main_text.configure(\n                wraplength=self.content_banner_main_text._current_width\n                - 40  # random padding\n            ),\n        )\n        # nested frame for holding filters and text inside banner frame\n\n        self.select_state_label = ctk.CTkLabel(\n            self.state_and_year_content_banner_dropdown_frame,\n            text=\"Select State\",\n            font=self.roboto_font,\n        )\n        self.select_state_dropdown = ctk.CTkOptionMenu(\n            self.state_and_year_content_banner_dropdown_frame,\n            values=None,\n            command=self.state_dropdown_callback,\n        )\n\n        self.select_year_label = ctk.CTkLabel(\n            self.state_and_year_content_banner_dropdown_frame,\n            text=\"Select Year\",\n            font=self.roboto_font,\n        )\n        self.select_year_dropdown = ctk.CTkOptionMenu(\n            self.state_and_year_content_banner_dropdown_frame,\n            values=self.years,\n            command=self.year_dropdown_callback,\n        )\n\n        self.energy_graph_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n\n        self.census_reporter_state_label = ctk.CTkLabel(\n            self.census_reporter_frame,\n            text=\"Census Reporter: State Report\",\n            font=self.roboto_link_font,\n            cursor=\"hand2\",\n            text_color=\"blue\",\n        )\n\n        self.log_button = ctk.CTkButton(\n            self.log_frame, text=\"Open Log File\", command=self.open_log_file\n        )\n        self.census_reporter_state_label.bind(\n            \"&lt;Button-1&gt;\", lambda x: self.open_census_reporter_state()\n        )\n        self.census_reporter_metro_label = ctk.CTkLabel(\n            self.census_reporter_frame,\n            text=\"Census Reporter: Metro Report\",\n            font=self.roboto_link_font,\n            cursor=\"hand2\",\n            text_color=\"blue\",\n        )\n        self.census_reporter_metro_label.bind(\n            \"&lt;Button-1&gt;\", lambda x: self.open_census_reporter_metro()\n        )\n        # create grid\n        # col\n        self.columnconfigure(0, weight=1)\n        self.content_frame.columnconfigure(0, weight=1)\n        self.content_banner_frame.columnconfigure((0, 1), weight=1)\n        self.state_and_year_content_banner_dropdown_frame.columnconfigure(\n            (0, 1), weight=1\n        )\n        self.energy_graph_frame.columnconfigure(0, weight=1)\n        self.census_reporter_frame.columnconfigure(0, weight=1)\n        self.log_frame.columnconfigure(0, weight=1)\n\n        # row\n        self.rowconfigure(0, weight=1)\n\n        self.content_frame.rowconfigure(0, weight=1)  # banner\n        self.content_frame.rowconfigure(1, weight=5)  # energy graph\n        self.content_frame.rowconfigure(2, weight=2)  # census reporter frame\n        self.content_frame.rowconfigure(3, weight=1)\n\n        self.content_banner_frame.rowconfigure(0, weight=1)\n\n        self.state_and_year_content_banner_dropdown_frame.rowconfigure((0, 1), weight=1)\n\n        self.energy_graph_frame.rowconfigure(0, weight=1)\n\n        self.census_reporter_frame.rowconfigure((0, 1), weight=1)\n\n        self.log_frame.rowconfigure(0, weight=1)\n\n        # placement\n        self.content_frame.grid(column=0, row=0, sticky=\"news\")\n\n        self.content_banner_frame.grid(column=0, row=0, sticky=\"news\")\n\n        self.content_banner_main_text.grid(column=0, row=0, sticky=\"nsew\")\n\n        self.state_and_year_content_banner_dropdown_frame.grid(\n            column=1, row=0, sticky=\"news\"\n        )\n\n        self.select_state_label.grid(column=0, row=0, sticky=\"news\")\n        self.select_year_label.grid(column=1, row=0, sticky=\"news\")\n        self.select_state_dropdown.grid(column=0, row=1)\n        self.select_year_dropdown.grid(column=1, row=1)\n\n        self.energy_graph_frame.grid(column=0, row=1, sticky=\"news\")\n\n        self.census_reporter_frame.grid(column=0, row=2, sticky=\"news\")\n        self.census_reporter_state_label.grid(column=0, row=0)\n        self.census_reporter_metro_label.grid(column=0, row=1)\n\n        self.log_frame.grid(column=0, row=3, sticky=\"news\")\n        self.log_button.grid(column=0, row=0, pady=10)\n\n    def set_msa_name(self, msa_name: str) -&gt; None:\n        \"\"\"Set the msa name and update objects that rely on the msa name. Includes drop downs and and generating the energy plot.\n\n        Args:\n            msa_name (str): Metropolitan Statistical Area name. This must be validated\n        \"\"\"\n        self.msa_name = msa_name\n        self.states_in_msa = helper.get_states_in_msa(self.msa_name)\n\n        if len(self.states_in_msa) &gt; 0:\n            self.select_state_dropdown.configure()\n            self.select_state_dropdown.set(self.states_in_msa[0])\n\n        self.select_state_dropdown.configure(values=self.states_in_msa)\n        self.content_banner_main_text.configure(\n            text=f\"Census and Energy Data: {self.msa_name}\"\n        )\n        self.zip_list = helper.metro_name_to_zip_code_list(msa_name)\n        self.zip_list = [str(zip) for zip in self.zip_list]\n\n        threading.Thread(\n            target=self.generate_energy_plot,\n            args=(\n                int(self.select_year_dropdown.get()),\n                self.select_state_dropdown.get(),\n            ),\n            daemon=True,\n        ).start()\n\n    def generate_energy_plot(self, year: int, state: str) -&gt; None:\n        \"\"\"Call the EIA API and generate a plot with the received data.\n\n        Note:\n            Call this in a thread so that it doesn't freeze the GUI\n            Update: might want to just get the data and plot on the main thread\n        \"\"\"\n        eia = EIADataRetriever()\n        energy_price_per_mbtu_by_type_for_state = (\n            eia.monthly_price_per_mbtu_by_energy_type_by_state(\n                state, datetime.date(year, 1, 1), datetime.date(year + 1, 1, 1)\n            )\n        )\n\n        fig = Figure(layout=\"compressed\", facecolor=\"blue\")\n        ax = fig.add_subplot()\n        ax.set_xlabel(\"Time (Months)\")\n        ax.set_ylabel(\"Cost per Effective MBTU ($/MBTU)\")\n        ax.set_title(\n            f\"Avg. Energy Prices by Appliance for {state}, {year}\",\n            loc=\"center\",\n            wrap=True,\n        )\n        months = [i for i in range(1, 13)]\n        month_names = [\n            \"Jan\",\n            \"Feb\",\n            \"Mar\",\n            \"Apr\",\n            \"May\",\n            \"Jun\",\n            \"Jul\",\n            \"Aug\",\n            \"Sep\",\n            \"Oct\",\n            \"Nov\",\n            \"Dec\",\n        ]\n        ax.set_xticks(months)\n        labels = [item.get_text() for item in ax.get_xticklabels()]\n\n        # Modify specific labels, keeping offset\n        for i in range(0, 12):\n            labels[i] = month_names[i]\n        ax.set_xticklabels(labels)\n\n        for energy_dict in energy_price_per_mbtu_by_type_for_state:\n            if len(energy_dict) &lt; 3:\n                log(\n                    f\"Issue with energy type {energy_dict.get(\"type\")} for state {energy_dict.get(\"state\")}\",\n                    \"debug\",\n                )\n                continue\n            match energy_dict.get(\"type\"):\n                case EIADataRetriever.EnergyType.PROPANE.value:\n                    result_list = []\n                    for month in months:\n                        key = f\"{year}-{month:02}\"\n                        val = energy_dict.get(key, float(\"NaN\"))\n                        if val is None:\n                            val = float(\"NaN\")\n                        result_list.append(val)\n                    ax.plot(months, result_list, label=\"Propane Furnace\")\n                case EIADataRetriever.EnergyType.HEATING_OIL.value:\n                    result_list = []\n                    for month in months:\n                        key = f\"{year}-{month:02}\"\n                        val = energy_dict.get(key, float(\"NaN\"))\n                        if val is None:\n                            val = float(\"NaN\")\n                        result_list.append(val)\n                    ax.plot(months, result_list, label=\"Heating Oil Boiler\")\n                case EIADataRetriever.EnergyType.NATURAL_GAS.value:\n                    result_list = []\n                    for month in months:\n                        key = f\"{year}-{month:02}\"\n                        val = energy_dict.get(key, float(\"NaN\"))\n                        if val is None:\n                            val = float(\"NaN\")\n                        result_list.append(val)\n                    ax.plot(months, result_list, label=\"Natural Gas Furnace\")\n                case EIADataRetriever.EnergyType.ELECTRICITY.value:\n                    result_list = []\n                    for month in months:\n                        key = f\"{year}-{month:02}\"\n                        val = energy_dict.get(key, float(\"NaN\"))\n                        if val is None:\n                            val = float(\"NaN\")\n                        result_list.append(val)\n                    ax.plot(months, result_list, label=\"Ducted Heat Pump\")\n        ax.legend()\n        with threading.Lock():\n            canvas = FigureCanvasTkAgg(fig, master=self.energy_graph_frame)\n            canvas.draw()\n\n            # toolbar = NavigationToolbar2Tk(canvas, window=self.energy_graph_frame, pack_toolbar=False)\n            # toolbar.update()\n            # canvas.mpl_connect(\"key_press_event\", key_press_handler)\n\n            # toolbar.grid(column=0, row=1, sticky=\"news\")\n            canvas.get_tk_widget().grid(column=0, row=0)\n\n    def open_census_reporter_state(self) -&gt; None:\n        \"\"\"Census reporter state label callback\"\"\"\n        state_link = helper.get_census_report_url_page(\n            sts.lookup(self.select_state_dropdown.get()).name  # type: ignore\n        )\n        webbrowser.open_new_tab(state_link)\n\n    def open_census_reporter_metro(self) -&gt; None:\n        \"\"\"Census reporter metro label callback\"\"\"\n        metro_link = helper.get_census_report_url_page(f\"{self.msa_name} metro area\")  # type: ignore\n        webbrowser.open_new_tab(metro_link)\n\n    def state_dropdown_callback(self, state: str) -&gt; None:\n        \"\"\"Banner state callback.\n        TODO:\n            check if thread is running with given name, and if so join it and start the new thread\n\n        Args:\n            state (str): the state after the change\n        \"\"\"\n\n        threading.Thread(\n            target=self.generate_energy_plot,\n            args=(\n                int(self.select_year_dropdown.get()),\n                state,\n            ),\n            name=\"energy_thread\",\n            daemon=True,\n        ).start()\n\n    def year_dropdown_callback(self, year: str) -&gt; None:\n        \"\"\"Banner year callback.\n        TODO:\n            Check if thread is running with given name, and if so join it and start the new thread\n\n        Args:\n            year (str): the year after the change\n        \"\"\"\n        threading.Thread(\n            target=self.generate_energy_plot,\n            args=(\n                int(year),\n                self.select_state_dropdown.get(),\n            ),\n            name=\"energy_thread\",\n            daemon=True,\n        ).start()\n\n    def open_log_file(self) -&gt; None:\n        \"\"\"Open logging file.\n\n        Note:\n            Haven't tested this on mac/linux. \"darwin\" doesn't exist in `system.platform` on windows, so cant say for sure if this works\n        \"\"\"\n        try:\n            if sys.platform == \"win32\":\n                startfile(helper.LOGGING_FILE_PATH)\n            else:\n                opener = \"open\" if sys.platform == \"darwin\" else \"xdg-open\"\n                subprocess.call([opener, helper.LOGGING_FILE_PATH])\n        except FileNotFoundError:\n            CTkMessagebox(\n                self,\n                title=\"Error\",\n                message=\"Logging file doesn't exist! Try rerunning the program or creating a logger.log file in /output/logging/\",\n                icon=\"warning\",\n            )\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Create widgets.</p> Source code in <code>src\\gui\\datapage.py</code> <pre><code>def create_widgets(self) -&gt; None:\n    \"\"\"Create widgets.\"\"\"\n    # bug in sockets library wont allow you to raise keyboardinterrupt, so stopping\n    # Content frame will have 4 rows. first will be header, 2nd is energy graph, 3rd will contain a frame that has censusreport.org links, 4th will have progress bar frame\n    self.content_frame = ctk.CTkFrame(self, border_width=2)\n    self.content_banner_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n    self.state_and_year_content_banner_dropdown_frame = ctk.CTkFrame(\n        self.content_banner_frame, border_width=2\n    )\n    self.census_reporter_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n    self.log_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n\n    self.content_banner_main_text = ctk.CTkLabel(\n        self.content_banner_frame,\n        text=\"Census and Energy Data:\",\n        font=self.roboto_header_font,\n    )\n    self.content_banner_main_text.bind(\n        \"&lt;Configure&gt;\",\n        command=lambda x: self.content_banner_main_text.configure(\n            wraplength=self.content_banner_main_text._current_width\n            - 40  # random padding\n        ),\n    )\n    # nested frame for holding filters and text inside banner frame\n\n    self.select_state_label = ctk.CTkLabel(\n        self.state_and_year_content_banner_dropdown_frame,\n        text=\"Select State\",\n        font=self.roboto_font,\n    )\n    self.select_state_dropdown = ctk.CTkOptionMenu(\n        self.state_and_year_content_banner_dropdown_frame,\n        values=None,\n        command=self.state_dropdown_callback,\n    )\n\n    self.select_year_label = ctk.CTkLabel(\n        self.state_and_year_content_banner_dropdown_frame,\n        text=\"Select Year\",\n        font=self.roboto_font,\n    )\n    self.select_year_dropdown = ctk.CTkOptionMenu(\n        self.state_and_year_content_banner_dropdown_frame,\n        values=self.years,\n        command=self.year_dropdown_callback,\n    )\n\n    self.energy_graph_frame = ctk.CTkFrame(self.content_frame, border_width=2)\n\n    self.census_reporter_state_label = ctk.CTkLabel(\n        self.census_reporter_frame,\n        text=\"Census Reporter: State Report\",\n        font=self.roboto_link_font,\n        cursor=\"hand2\",\n        text_color=\"blue\",\n    )\n\n    self.log_button = ctk.CTkButton(\n        self.log_frame, text=\"Open Log File\", command=self.open_log_file\n    )\n    self.census_reporter_state_label.bind(\n        \"&lt;Button-1&gt;\", lambda x: self.open_census_reporter_state()\n    )\n    self.census_reporter_metro_label = ctk.CTkLabel(\n        self.census_reporter_frame,\n        text=\"Census Reporter: Metro Report\",\n        font=self.roboto_link_font,\n        cursor=\"hand2\",\n        text_color=\"blue\",\n    )\n    self.census_reporter_metro_label.bind(\n        \"&lt;Button-1&gt;\", lambda x: self.open_census_reporter_metro()\n    )\n    # create grid\n    # col\n    self.columnconfigure(0, weight=1)\n    self.content_frame.columnconfigure(0, weight=1)\n    self.content_banner_frame.columnconfigure((0, 1), weight=1)\n    self.state_and_year_content_banner_dropdown_frame.columnconfigure(\n        (0, 1), weight=1\n    )\n    self.energy_graph_frame.columnconfigure(0, weight=1)\n    self.census_reporter_frame.columnconfigure(0, weight=1)\n    self.log_frame.columnconfigure(0, weight=1)\n\n    # row\n    self.rowconfigure(0, weight=1)\n\n    self.content_frame.rowconfigure(0, weight=1)  # banner\n    self.content_frame.rowconfigure(1, weight=5)  # energy graph\n    self.content_frame.rowconfigure(2, weight=2)  # census reporter frame\n    self.content_frame.rowconfigure(3, weight=1)\n\n    self.content_banner_frame.rowconfigure(0, weight=1)\n\n    self.state_and_year_content_banner_dropdown_frame.rowconfigure((0, 1), weight=1)\n\n    self.energy_graph_frame.rowconfigure(0, weight=1)\n\n    self.census_reporter_frame.rowconfigure((0, 1), weight=1)\n\n    self.log_frame.rowconfigure(0, weight=1)\n\n    # placement\n    self.content_frame.grid(column=0, row=0, sticky=\"news\")\n\n    self.content_banner_frame.grid(column=0, row=0, sticky=\"news\")\n\n    self.content_banner_main_text.grid(column=0, row=0, sticky=\"nsew\")\n\n    self.state_and_year_content_banner_dropdown_frame.grid(\n        column=1, row=0, sticky=\"news\"\n    )\n\n    self.select_state_label.grid(column=0, row=0, sticky=\"news\")\n    self.select_year_label.grid(column=1, row=0, sticky=\"news\")\n    self.select_state_dropdown.grid(column=0, row=1)\n    self.select_year_dropdown.grid(column=1, row=1)\n\n    self.energy_graph_frame.grid(column=0, row=1, sticky=\"news\")\n\n    self.census_reporter_frame.grid(column=0, row=2, sticky=\"news\")\n    self.census_reporter_state_label.grid(column=0, row=0)\n    self.census_reporter_metro_label.grid(column=0, row=1)\n\n    self.log_frame.grid(column=0, row=3, sticky=\"news\")\n    self.log_button.grid(column=0, row=0, pady=10)\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.generate_energy_plot","title":"<code>generate_energy_plot(year, state)</code>","text":"<p>Call the EIA API and generate a plot with the received data.</p> Note <p>Call this in a thread so that it doesn't freeze the GUI Update: might want to just get the data and plot on the main thread</p> Source code in <code>src\\gui\\datapage.py</code> <pre><code>def generate_energy_plot(self, year: int, state: str) -&gt; None:\n    \"\"\"Call the EIA API and generate a plot with the received data.\n\n    Note:\n        Call this in a thread so that it doesn't freeze the GUI\n        Update: might want to just get the data and plot on the main thread\n    \"\"\"\n    eia = EIADataRetriever()\n    energy_price_per_mbtu_by_type_for_state = (\n        eia.monthly_price_per_mbtu_by_energy_type_by_state(\n            state, datetime.date(year, 1, 1), datetime.date(year + 1, 1, 1)\n        )\n    )\n\n    fig = Figure(layout=\"compressed\", facecolor=\"blue\")\n    ax = fig.add_subplot()\n    ax.set_xlabel(\"Time (Months)\")\n    ax.set_ylabel(\"Cost per Effective MBTU ($/MBTU)\")\n    ax.set_title(\n        f\"Avg. Energy Prices by Appliance for {state}, {year}\",\n        loc=\"center\",\n        wrap=True,\n    )\n    months = [i for i in range(1, 13)]\n    month_names = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\",\n    ]\n    ax.set_xticks(months)\n    labels = [item.get_text() for item in ax.get_xticklabels()]\n\n    # Modify specific labels, keeping offset\n    for i in range(0, 12):\n        labels[i] = month_names[i]\n    ax.set_xticklabels(labels)\n\n    for energy_dict in energy_price_per_mbtu_by_type_for_state:\n        if len(energy_dict) &lt; 3:\n            log(\n                f\"Issue with energy type {energy_dict.get(\"type\")} for state {energy_dict.get(\"state\")}\",\n                \"debug\",\n            )\n            continue\n        match energy_dict.get(\"type\"):\n            case EIADataRetriever.EnergyType.PROPANE.value:\n                result_list = []\n                for month in months:\n                    key = f\"{year}-{month:02}\"\n                    val = energy_dict.get(key, float(\"NaN\"))\n                    if val is None:\n                        val = float(\"NaN\")\n                    result_list.append(val)\n                ax.plot(months, result_list, label=\"Propane Furnace\")\n            case EIADataRetriever.EnergyType.HEATING_OIL.value:\n                result_list = []\n                for month in months:\n                    key = f\"{year}-{month:02}\"\n                    val = energy_dict.get(key, float(\"NaN\"))\n                    if val is None:\n                        val = float(\"NaN\")\n                    result_list.append(val)\n                ax.plot(months, result_list, label=\"Heating Oil Boiler\")\n            case EIADataRetriever.EnergyType.NATURAL_GAS.value:\n                result_list = []\n                for month in months:\n                    key = f\"{year}-{month:02}\"\n                    val = energy_dict.get(key, float(\"NaN\"))\n                    if val is None:\n                        val = float(\"NaN\")\n                    result_list.append(val)\n                ax.plot(months, result_list, label=\"Natural Gas Furnace\")\n            case EIADataRetriever.EnergyType.ELECTRICITY.value:\n                result_list = []\n                for month in months:\n                    key = f\"{year}-{month:02}\"\n                    val = energy_dict.get(key, float(\"NaN\"))\n                    if val is None:\n                        val = float(\"NaN\")\n                    result_list.append(val)\n                ax.plot(months, result_list, label=\"Ducted Heat Pump\")\n    ax.legend()\n    with threading.Lock():\n        canvas = FigureCanvasTkAgg(fig, master=self.energy_graph_frame)\n        canvas.draw()\n\n        # toolbar = NavigationToolbar2Tk(canvas, window=self.energy_graph_frame, pack_toolbar=False)\n        # toolbar.update()\n        # canvas.mpl_connect(\"key_press_event\", key_press_handler)\n\n        # toolbar.grid(column=0, row=1, sticky=\"news\")\n        canvas.get_tk_widget().grid(column=0, row=0)\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.open_census_reporter_metro","title":"<code>open_census_reporter_metro()</code>","text":"<p>Census reporter metro label callback</p> Source code in <code>src\\gui\\datapage.py</code> <pre><code>def open_census_reporter_metro(self) -&gt; None:\n    \"\"\"Census reporter metro label callback\"\"\"\n    metro_link = helper.get_census_report_url_page(f\"{self.msa_name} metro area\")  # type: ignore\n    webbrowser.open_new_tab(metro_link)\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.open_census_reporter_state","title":"<code>open_census_reporter_state()</code>","text":"<p>Census reporter state label callback</p> Source code in <code>src\\gui\\datapage.py</code> <pre><code>def open_census_reporter_state(self) -&gt; None:\n    \"\"\"Census reporter state label callback\"\"\"\n    state_link = helper.get_census_report_url_page(\n        sts.lookup(self.select_state_dropdown.get()).name  # type: ignore\n    )\n    webbrowser.open_new_tab(state_link)\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.open_log_file","title":"<code>open_log_file()</code>","text":"<p>Open logging file.</p> Note <p>Haven't tested this on mac/linux. \"darwin\" doesn't exist in <code>system.platform</code> on windows, so cant say for sure if this works</p> Source code in <code>src\\gui\\datapage.py</code> <pre><code>def open_log_file(self) -&gt; None:\n    \"\"\"Open logging file.\n\n    Note:\n        Haven't tested this on mac/linux. \"darwin\" doesn't exist in `system.platform` on windows, so cant say for sure if this works\n    \"\"\"\n    try:\n        if sys.platform == \"win32\":\n            startfile(helper.LOGGING_FILE_PATH)\n        else:\n            opener = \"open\" if sys.platform == \"darwin\" else \"xdg-open\"\n            subprocess.call([opener, helper.LOGGING_FILE_PATH])\n    except FileNotFoundError:\n        CTkMessagebox(\n            self,\n            title=\"Error\",\n            message=\"Logging file doesn't exist! Try rerunning the program or creating a logger.log file in /output/logging/\",\n            icon=\"warning\",\n        )\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.set_msa_name","title":"<code>set_msa_name(msa_name)</code>","text":"<p>Set the msa name and update objects that rely on the msa name. Includes drop downs and and generating the energy plot.</p> <p>Parameters:</p> Name Type Description Default <code>msa_name</code> <code>str</code> <p>Metropolitan Statistical Area name. This must be validated</p> required Source code in <code>src\\gui\\datapage.py</code> <pre><code>def set_msa_name(self, msa_name: str) -&gt; None:\n    \"\"\"Set the msa name and update objects that rely on the msa name. Includes drop downs and and generating the energy plot.\n\n    Args:\n        msa_name (str): Metropolitan Statistical Area name. This must be validated\n    \"\"\"\n    self.msa_name = msa_name\n    self.states_in_msa = helper.get_states_in_msa(self.msa_name)\n\n    if len(self.states_in_msa) &gt; 0:\n        self.select_state_dropdown.configure()\n        self.select_state_dropdown.set(self.states_in_msa[0])\n\n    self.select_state_dropdown.configure(values=self.states_in_msa)\n    self.content_banner_main_text.configure(\n        text=f\"Census and Energy Data: {self.msa_name}\"\n    )\n    self.zip_list = helper.metro_name_to_zip_code_list(msa_name)\n    self.zip_list = [str(zip) for zip in self.zip_list]\n\n    threading.Thread(\n        target=self.generate_energy_plot,\n        args=(\n            int(self.select_year_dropdown.get()),\n            self.select_state_dropdown.get(),\n        ),\n        daemon=True,\n    ).start()\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.state_dropdown_callback","title":"<code>state_dropdown_callback(state)</code>","text":"<p>Banner state callback. TODO:     check if thread is running with given name, and if so join it and start the new thread</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>str</code> <p>the state after the change</p> required Source code in <code>src\\gui\\datapage.py</code> <pre><code>def state_dropdown_callback(self, state: str) -&gt; None:\n    \"\"\"Banner state callback.\n    TODO:\n        check if thread is running with given name, and if so join it and start the new thread\n\n    Args:\n        state (str): the state after the change\n    \"\"\"\n\n    threading.Thread(\n        target=self.generate_energy_plot,\n        args=(\n            int(self.select_year_dropdown.get()),\n            state,\n        ),\n        name=\"energy_thread\",\n        daemon=True,\n    ).start()\n</code></pre>"},{"location":"gui/datapage/#gui.datapage.DataPage.year_dropdown_callback","title":"<code>year_dropdown_callback(year)</code>","text":"<p>Banner year callback. TODO:     Check if thread is running with given name, and if so join it and start the new thread</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>str</code> <p>the year after the change</p> required Source code in <code>src\\gui\\datapage.py</code> <pre><code>def year_dropdown_callback(self, year: str) -&gt; None:\n    \"\"\"Banner year callback.\n    TODO:\n        Check if thread is running with given name, and if so join it and start the new thread\n\n    Args:\n        year (str): the year after the change\n    \"\"\"\n    threading.Thread(\n        target=self.generate_energy_plot,\n        args=(\n            int(year),\n            self.select_state_dropdown.get(),\n        ),\n        name=\"energy_thread\",\n        daemon=True,\n    ).start()\n</code></pre>"},{"location":"gui/filterspage/","title":"Filterspage","text":""},{"location":"gui/filterspage/#gui.filterspage.FiltersPage","title":"<code>FiltersPage</code>","text":"<p>             Bases: <code>CTkFrame</code></p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>class FiltersPage(ctk.CTkFrame):\n    def __init__(self, master: ctk.CTk, search_page: ctk.CTkFrame, **kwargs):\n        # main setup\n        super().__init__(master, **kwargs)\n        self.root = master\n        self.search_page = search_page\n        self.cur_year = datetime.datetime.now().year\n        self.year_list = [str(x) for x in range(2010, self.cur_year + 1)]\n        list.reverse(self.year_list)\n        self.sqft_list = [sqft.value for sqft in RedfinApi.Sqft]\n        list.reverse(self.sqft_list)\n        self.sold_within_list = [\n            \"Last 1 week\",\n            \"Last 1 month\",\n            \"Last 3 months\",\n            \"Last 6 months\",\n            \"Last 1 year\",\n            \"Last 2 years\",\n            \"Last 3 years\",\n            \"Last 5 years\",\n        ]\n        self.price_list = [price.value for price in RedfinApi.Price]\n        list.reverse(self.price_list)\n        self.create_widgets()\n        self.set_default_values()\n\n    def create_widgets(self) -&gt; None:\n        \"\"\"Create widgets.\"\"\"\n        # frames\n        self.content_frame = ctk.CTkFrame(self)\n        self.for_sale_sold_frame = ctk.CTkFrame(\n            self.content_frame, width=300, height=100, fg_color=\"transparent\"\n        )\n        self.stories_frame = ctk.CTkFrame(self.content_frame)\n        self.year_built_frame = ctk.CTkFrame(self.content_frame, fg_color=\"transparent\")\n        self.home_type_frame = ctk.CTkFrame(self.content_frame)\n        self.square_feet_frame = ctk.CTkFrame(self.content_frame)\n        self.status_frame = ctk.CTkFrame(self.content_frame)\n        self.sold_within_frame = ctk.CTkFrame(self.content_frame)\n        self.price_range_frame = ctk.CTkFrame(self.content_frame)\n        self.reset_apply_frame = ctk.CTkFrame(self.content_frame)\n\n        # make more grid\n        self.columnconfigure((0, 2), weight=1)\n        self.columnconfigure(1, weight=30)\n        self.content_frame.columnconfigure((0), weight=1, uniform=\"a\")  # uniform\n        self.for_sale_sold_frame.columnconfigure((0, 1), weight=1)\n        self.stories_frame.columnconfigure((0, 1), weight=1)\n        self.year_built_frame.columnconfigure((0, 1, 2, 3), weight=1)\n        self.home_type_frame.columnconfigure((0, 1, 2, 3), weight=1)\n        self.square_feet_frame.columnconfigure((0, 1, 2, 3), weight=1)\n        self.status_frame.columnconfigure((0, 1, 2), weight=1)\n        self.sold_within_frame.columnconfigure((0, 1), weight=1)\n        self.price_range_frame.columnconfigure((0, 1, 2, 3), weight=1)\n        self.reset_apply_frame.columnconfigure((0, 1), weight=1)\n\n        self.rowconfigure((0, 2), weight=1)\n        self.rowconfigure(1, weight=30)\n        self.content_frame.rowconfigure(\n            (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), weight=1, uniform=\"a\"\n        )\n        self.for_sale_sold_frame.rowconfigure(0, weight=1)\n        self.stories_frame.rowconfigure(0, weight=1)\n        self.year_built_frame.rowconfigure((0, 1), weight=1)\n        self.home_type_frame.rowconfigure((0, 1, 2), weight=1)\n        self.square_feet_frame.rowconfigure((0, 1), weight=1)\n        self.status_frame.rowconfigure((0, 1), weight=1)\n        self.sold_within_frame.rowconfigure(0, weight=1)\n        self.price_range_frame.rowconfigure((0, 1), weight=1)\n        self.reset_apply_frame.rowconfigure(0, weight=1)\n\n        # placing the frames\n        self.content_frame.grid(row=1, column=1)\n        self.for_sale_sold_frame.grid(row=0, column=0, sticky=\"nsew\")\n        self.stories_frame.grid(row=1, column=0, sticky=\"nesw\")\n        self.year_built_frame.grid(row=2, column=0, sticky=\"nesw\")\n        self.home_type_frame.grid(row=3, column=0, rowspan=2, sticky=\"nesw\")\n        self.square_feet_frame.grid(row=5, column=0, sticky=\"nesw\")\n        self.status_frame.grid(row=6, column=0)\n        self.sold_within_frame.grid(row=7, column=0, sticky=\"nesw\")\n        self.price_range_frame.grid(row=8, column=0, rowspan=2, sticky=\"nesw\")\n        self.reset_apply_frame.grid(row=10, column=0)\n\n        # Create the labels\n        self.for_sale_sold_label = ctk.CTkLabel(\n            self.for_sale_sold_frame, text=\"For Sale/Sold\"\n        )\n        self.stories_label = ctk.CTkLabel(self.stories_frame, text=\"Stories\")\n        self.year_built_label = ctk.CTkLabel(self.year_built_frame, text=\"Year Built\")\n        self.home_type_label = ctk.CTkLabel(self.home_type_frame, text=\"Home Type\")\n        self.sqft_label = ctk.CTkLabel(self.square_feet_frame, text=\"Square Feet\")\n        self.sale_status_label = ctk.CTkLabel(self.status_frame, text=\"Status\")\n        self.price_range_label = ctk.CTkLabel(\n            self.price_range_frame, text=\"Price Range\"\n        )\n        self.price_range_from_label = ctk.CTkLabel(self.price_range_frame, text=\"From\")\n        self.price_range_to_label = ctk.CTkLabel(self.price_range_frame, text=\"To\")\n        self.year_built_from_label = ctk.CTkLabel(self.year_built_frame, text=\"From\")\n        self.year_built_to_label = ctk.CTkLabel(self.year_built_frame, text=\"To\")\n        self.sold_within_label = ctk.CTkLabel(\n            self.sold_within_frame, text=\"Sold Within\"\n        )\n        self.sold_within_from_label = ctk.CTkLabel(self.square_feet_frame, text=\"From\")\n        self.sold_within_to_label = ctk.CTkLabel(self.square_feet_frame, text=\"To\")\n\n        # Create the Buttons\n        self.for_sale_sold_om = ctk.CTkOptionMenu(\n            master=self.for_sale_sold_frame,\n            values=[status.value for status in RedfinApi.SoldStatus],\n            command=lambda x: self.status_within_activate_deactivate(x),\n        )\n\n        self.min_stories_om = ctk.CTkOptionMenu(\n            self.stories_frame, values=[story.value for story in RedfinApi.Stories]\n        )\n\n        self.min_year_built_om = ctk.CTkOptionMenu(\n            self.year_built_frame,\n            values=self.year_list,\n            command=lambda x: self.year_validation(),\n        )\n\n        self.max_year_built_om = ctk.CTkOptionMenu(\n            self.year_built_frame,\n            values=self.year_list,\n            command=lambda x: self.year_validation(),\n        )\n\n        self.house_type_house_switch = ctk.CTkSwitch(\n            self.home_type_frame,\n            text=\"House\",\n            command=self.house_type_validation,\n        )\n        self.house_type_townhouse_switch = ctk.CTkSwitch(\n            self.home_type_frame,\n            text=\"Townhouse\",\n            command=self.house_type_validation,\n        )\n        self.house_type_condo_switch = ctk.CTkSwitch(\n            self.home_type_frame,\n            text=\"Condo\",\n            command=self.house_type_validation,\n        )\n        self.house_type_mul_fam_switch = ctk.CTkSwitch(\n            self.home_type_frame,\n            text=\"Multi-Family\",\n            command=self.house_type_validation,\n        )\n\n        self.min_sqft_om = ctk.CTkOptionMenu(\n            self.square_feet_frame,\n            values=self.sqft_list,\n            command=lambda x: self.sqft_validation(),\n        )\n        self.max_sqft_om = ctk.CTkOptionMenu(\n            self.square_feet_frame,\n            values=self.sqft_list,\n            command=lambda x: self.sqft_validation(),\n        )\n        self.status_coming_soon_chb = ctk.CTkCheckBox(\n            self.status_frame, text=\"Coming soon\"\n        )\n        self.status_active_chb = ctk.CTkCheckBox(self.status_frame, text=\"Active\")\n        self.status_pending_chb = ctk.CTkCheckBox(\n            self.status_frame, text=\"Under contract/Pending\"\n        )  # missing one i think\n        self.sold_within_om = ctk.CTkOptionMenu(\n            self.sold_within_frame, values=self.sold_within_list\n        )\n\n        self.min_price_om = ctk.CTkOptionMenu(\n            self.price_range_frame,\n            values=self.price_list,\n            command=lambda x: self.price_validation(),\n        )\n        self.max_price_om = ctk.CTkOptionMenu(\n            self.price_range_frame,\n            values=self.price_list,\n            command=lambda x: self.price_validation(),\n        )\n\n        self.reset_filters_button = ctk.CTkButton(\n            self.reset_apply_frame,\n            text=\"Reset Filters\",\n            command=self.set_default_values,\n        )\n        self.apply_filters_button = ctk.CTkButton(\n            self.reset_apply_frame,\n            text=\"Apply Filters\",\n            command=self.change_to_search_page,\n        )\n\n        # Placing the widgets\n        self.for_sale_sold_label.grid(row=0, column=0)\n        self.stories_label.grid(row=0, column=0)\n        self.year_built_label.grid(row=0, column=0)\n        self.home_type_label.grid(row=0, column=0)\n        self.sqft_label.grid(row=0, column=0)\n        self.sale_status_label.grid(row=0, column=0)\n        self.price_range_label.grid(row=0, column=0)\n        self.year_built_from_label.grid(row=1, column=0)\n        self.year_built_to_label.grid(row=1, column=2)\n        self.price_range_from_label.grid(row=1, column=0)\n        self.price_range_to_label.grid(row=1, column=2)\n        self.sold_within_label.grid(row=0, column=0)\n        self.sold_within_from_label.grid(row=1, column=0)\n        self.sold_within_to_label.grid(row=1, column=2)\n\n        self.for_sale_sold_om.grid(row=0, column=1)\n        self.min_stories_om.grid(row=0, column=1)\n        self.min_year_built_om.grid(row=1, column=1)\n        self.max_year_built_om.grid(row=1, column=3)\n        self.min_sqft_om.grid(row=1, column=1)\n        self.max_sqft_om.grid(row=1, column=3)\n        self.sold_within_om.grid(row=0, column=1)\n        self.min_price_om.grid(row=1, column=1)\n        self.max_price_om.grid(row=1, column=3)\n        self.house_type_house_switch.grid(row=1, column=0)\n        self.house_type_townhouse_switch.grid(row=1, column=1)\n        self.house_type_condo_switch.grid(row=2, column=0)\n        self.house_type_mul_fam_switch.grid(row=2, column=1)\n        self.status_coming_soon_chb.grid(row=1, column=0)\n        self.status_active_chb.grid(row=1, column=1)\n        self.status_pending_chb.grid(row=1, column=2)\n        self.reset_filters_button.grid(row=0, column=0, sticky=\"nesw\")\n        self.apply_filters_button.grid(row=0, column=1, sticky=\"nesw\")\n\n    def set_default_values(self) -&gt; None:\n        \"\"\"Set the default values for all widgets.\n        Note:\n            Should be called after init and when clicking reset button.\n        \"\"\"\n        self.for_sale_sold_om.set(RedfinApi.SoldStatus.SOLD.value)\n        self.min_stories_om.set(RedfinApi.Stories.ONE.value)\n        self.min_year_built_om.set(str(self.cur_year - 1))\n        self.max_year_built_om.set(str(self.cur_year - 1))\n        self.sold_within_om.set(self.sold_within_list[-1])\n        self.max_price_om.set(RedfinApi.Price.NONE.value)\n        self.min_price_om.set(RedfinApi.Price.NONE.value)\n        self.max_sqft_om.set(RedfinApi.Sqft.NONE.value)\n        self.min_sqft_om.set(RedfinApi.Sqft.NONE.value)\n        self.status_active_chb.deselect()\n        self.status_pending_chb.deselect()\n        self.status_coming_soon_chb.deselect()\n        self.house_type_house_switch.select()\n        self.house_type_condo_switch.deselect()\n        self.house_type_townhouse_switch.deselect()\n        self.house_type_mul_fam_switch.deselect()\n        self.status_within_activate_deactivate(self.for_sale_sold_om.get())\n\n    def status_within_activate_deactivate(self, status) -&gt; None:\n        \"\"\"Deactivate or activate the status and sold within sections, since they depend on what type of sale a house is being searched with.\n\n        Args:\n            status (Event): ignored\n        \"\"\"\n        match self.for_sale_sold_om.get():\n            case RedfinApi.SoldStatus.FOR_SALE.value:\n                self.sale_status_label.configure(state=\"normal\")\n                self.status_active_chb.configure(state=\"normal\")\n                self.status_coming_soon_chb.configure(state=\"normal\")\n                self.status_pending_chb.configure(state=\"normal\")\n                self.sold_within_label.configure(state=\"disabled\")\n                self.sold_within_om.configure(state=\"disabled\")\n            case RedfinApi.SoldStatus.SOLD.value:\n                self.sale_status_label.configure(state=\"disabled\")\n                self.status_active_chb.configure(state=\"disabled\")\n                self.status_coming_soon_chb.configure(state=\"disabled\")\n                self.status_pending_chb.configure(state=\"disabled\")\n                self.sold_within_label.configure(state=\"normal\")\n                self.sold_within_om.configure(state=\"normal\")\n\n    def change_to_search_page(self) -&gt; None:\n        \"\"\"Change to search page.\"\"\"\n        self.grid_remove()\n        self.search_page.grid()\n\n    def price_validation(self):\n        \"\"\"Called when price range min om gets changed\"\"\"\n        if (\n            self.max_price_om.get() == RedfinApi.Price.NONE.value\n            or self.min_price_om.get() == RedfinApi.Price.NONE.value\n        ):\n            return\n        if int(self.max_price_om.get()) &lt; int(self.min_price_om.get()):\n            self.max_price_om.set(self.min_price_om.get())\n\n    def year_validation(self) -&gt; None:\n        \"\"\"Year drop down callback\"\"\"\n        if int(self.max_year_built_om.get()) &lt; int(self.min_year_built_om.get()):\n            self.max_year_built_om.set(self.min_year_built_om.get())\n\n    def sqft_validation(self) -&gt; None:\n        \"\"\"Sqft dropdown callback\"\"\"\n        if (\n            self.max_sqft_om.get() == RedfinApi.Sqft.NONE.value\n            or self.min_sqft_om.get() == RedfinApi.Sqft.NONE.value\n        ):\n            return\n        if int(self.max_sqft_om.get()) &lt; int(self.min_sqft_om.get()):\n            self.max_sqft_om.set(self.min_sqft_om.get())\n\n    def house_type_validation(self) -&gt; None:\n        \"\"\"House type switch validation to make sure at lest house is selected.\"\"\"\n        if not any(\n            [\n                self.house_type_house_switch.get(),\n                self.house_type_condo_switch.get(),\n                self.house_type_mul_fam_switch.get(),\n                self.house_type_townhouse_switch.get(),\n            ]\n        ):\n            self.house_type_house_switch.select()\n\n    def get_values(self) -&gt; dict[str, Any]:\n        \"\"\"Get the values of all widgets on this page.\n\n        Returns:\n            dict[str, Any]: dict of values\n        \"\"\"\n        match self.sold_within_om.get():\n            case \"Last 1 week\":\n                sold_within_days = RedfinApi.SoldWithinDays.ONE_WEEK\n            case \"Last 1 month\":\n                sold_within_days = RedfinApi.SoldWithinDays.ONE_MONTH\n            case \"Last 3 months\":\n                sold_within_days = RedfinApi.SoldWithinDays.THREE_MONTHS\n            case \"Last 6 months\":\n                sold_within_days = RedfinApi.SoldWithinDays.SIX_MONTHS\n            case \"Last 1 year\":\n                sold_within_days = RedfinApi.SoldWithinDays.ONE_YEAR\n            case \"Last 2 years\":\n                sold_within_days = RedfinApi.SoldWithinDays.TWO_YEARS\n            case \"Last 3 years\":\n                sold_within_days = RedfinApi.SoldWithinDays.THREE_YEARS\n            case _:\n                sold_within_days = RedfinApi.SoldWithinDays.FIVE_YEARS\n\n        return {\n            \"for sale sold\": self.for_sale_sold_om.get(),\n            \"min stories\": self.min_stories_om.get(),\n            \"max year built\": self.max_year_built_om.get(),  # do validation here\n            \"min year built\": self.min_year_built_om.get(),\n            \"sold within\": sold_within_days.value,\n            \"status active\": bool(self.status_active_chb.get()),\n            \"status coming soon\": bool(self.status_coming_soon_chb.get()),\n            \"status pending\": bool(self.status_pending_chb.get()),\n            \"house type house\": bool(self.house_type_house_switch.get()),\n            \"house type townhouse\": bool(self.house_type_townhouse_switch.get()),\n            \"house type mul fam\": bool(self.house_type_mul_fam_switch.get()),\n            \"house type condo\": bool(self.house_type_condo_switch.get()),\n            \"max sqft\": self.max_sqft_om.get(),\n            \"min sqft\": self.min_sqft_om.get(),\n            \"max price\": self.max_price_om.get(),\n            \"min price\": self.min_price_om.get(),\n        }\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.change_to_search_page","title":"<code>change_to_search_page()</code>","text":"<p>Change to search page.</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def change_to_search_page(self) -&gt; None:\n    \"\"\"Change to search page.\"\"\"\n    self.grid_remove()\n    self.search_page.grid()\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Create widgets.</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def create_widgets(self) -&gt; None:\n    \"\"\"Create widgets.\"\"\"\n    # frames\n    self.content_frame = ctk.CTkFrame(self)\n    self.for_sale_sold_frame = ctk.CTkFrame(\n        self.content_frame, width=300, height=100, fg_color=\"transparent\"\n    )\n    self.stories_frame = ctk.CTkFrame(self.content_frame)\n    self.year_built_frame = ctk.CTkFrame(self.content_frame, fg_color=\"transparent\")\n    self.home_type_frame = ctk.CTkFrame(self.content_frame)\n    self.square_feet_frame = ctk.CTkFrame(self.content_frame)\n    self.status_frame = ctk.CTkFrame(self.content_frame)\n    self.sold_within_frame = ctk.CTkFrame(self.content_frame)\n    self.price_range_frame = ctk.CTkFrame(self.content_frame)\n    self.reset_apply_frame = ctk.CTkFrame(self.content_frame)\n\n    # make more grid\n    self.columnconfigure((0, 2), weight=1)\n    self.columnconfigure(1, weight=30)\n    self.content_frame.columnconfigure((0), weight=1, uniform=\"a\")  # uniform\n    self.for_sale_sold_frame.columnconfigure((0, 1), weight=1)\n    self.stories_frame.columnconfigure((0, 1), weight=1)\n    self.year_built_frame.columnconfigure((0, 1, 2, 3), weight=1)\n    self.home_type_frame.columnconfigure((0, 1, 2, 3), weight=1)\n    self.square_feet_frame.columnconfigure((0, 1, 2, 3), weight=1)\n    self.status_frame.columnconfigure((0, 1, 2), weight=1)\n    self.sold_within_frame.columnconfigure((0, 1), weight=1)\n    self.price_range_frame.columnconfigure((0, 1, 2, 3), weight=1)\n    self.reset_apply_frame.columnconfigure((0, 1), weight=1)\n\n    self.rowconfigure((0, 2), weight=1)\n    self.rowconfigure(1, weight=30)\n    self.content_frame.rowconfigure(\n        (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), weight=1, uniform=\"a\"\n    )\n    self.for_sale_sold_frame.rowconfigure(0, weight=1)\n    self.stories_frame.rowconfigure(0, weight=1)\n    self.year_built_frame.rowconfigure((0, 1), weight=1)\n    self.home_type_frame.rowconfigure((0, 1, 2), weight=1)\n    self.square_feet_frame.rowconfigure((0, 1), weight=1)\n    self.status_frame.rowconfigure((0, 1), weight=1)\n    self.sold_within_frame.rowconfigure(0, weight=1)\n    self.price_range_frame.rowconfigure((0, 1), weight=1)\n    self.reset_apply_frame.rowconfigure(0, weight=1)\n\n    # placing the frames\n    self.content_frame.grid(row=1, column=1)\n    self.for_sale_sold_frame.grid(row=0, column=0, sticky=\"nsew\")\n    self.stories_frame.grid(row=1, column=0, sticky=\"nesw\")\n    self.year_built_frame.grid(row=2, column=0, sticky=\"nesw\")\n    self.home_type_frame.grid(row=3, column=0, rowspan=2, sticky=\"nesw\")\n    self.square_feet_frame.grid(row=5, column=0, sticky=\"nesw\")\n    self.status_frame.grid(row=6, column=0)\n    self.sold_within_frame.grid(row=7, column=0, sticky=\"nesw\")\n    self.price_range_frame.grid(row=8, column=0, rowspan=2, sticky=\"nesw\")\n    self.reset_apply_frame.grid(row=10, column=0)\n\n    # Create the labels\n    self.for_sale_sold_label = ctk.CTkLabel(\n        self.for_sale_sold_frame, text=\"For Sale/Sold\"\n    )\n    self.stories_label = ctk.CTkLabel(self.stories_frame, text=\"Stories\")\n    self.year_built_label = ctk.CTkLabel(self.year_built_frame, text=\"Year Built\")\n    self.home_type_label = ctk.CTkLabel(self.home_type_frame, text=\"Home Type\")\n    self.sqft_label = ctk.CTkLabel(self.square_feet_frame, text=\"Square Feet\")\n    self.sale_status_label = ctk.CTkLabel(self.status_frame, text=\"Status\")\n    self.price_range_label = ctk.CTkLabel(\n        self.price_range_frame, text=\"Price Range\"\n    )\n    self.price_range_from_label = ctk.CTkLabel(self.price_range_frame, text=\"From\")\n    self.price_range_to_label = ctk.CTkLabel(self.price_range_frame, text=\"To\")\n    self.year_built_from_label = ctk.CTkLabel(self.year_built_frame, text=\"From\")\n    self.year_built_to_label = ctk.CTkLabel(self.year_built_frame, text=\"To\")\n    self.sold_within_label = ctk.CTkLabel(\n        self.sold_within_frame, text=\"Sold Within\"\n    )\n    self.sold_within_from_label = ctk.CTkLabel(self.square_feet_frame, text=\"From\")\n    self.sold_within_to_label = ctk.CTkLabel(self.square_feet_frame, text=\"To\")\n\n    # Create the Buttons\n    self.for_sale_sold_om = ctk.CTkOptionMenu(\n        master=self.for_sale_sold_frame,\n        values=[status.value for status in RedfinApi.SoldStatus],\n        command=lambda x: self.status_within_activate_deactivate(x),\n    )\n\n    self.min_stories_om = ctk.CTkOptionMenu(\n        self.stories_frame, values=[story.value for story in RedfinApi.Stories]\n    )\n\n    self.min_year_built_om = ctk.CTkOptionMenu(\n        self.year_built_frame,\n        values=self.year_list,\n        command=lambda x: self.year_validation(),\n    )\n\n    self.max_year_built_om = ctk.CTkOptionMenu(\n        self.year_built_frame,\n        values=self.year_list,\n        command=lambda x: self.year_validation(),\n    )\n\n    self.house_type_house_switch = ctk.CTkSwitch(\n        self.home_type_frame,\n        text=\"House\",\n        command=self.house_type_validation,\n    )\n    self.house_type_townhouse_switch = ctk.CTkSwitch(\n        self.home_type_frame,\n        text=\"Townhouse\",\n        command=self.house_type_validation,\n    )\n    self.house_type_condo_switch = ctk.CTkSwitch(\n        self.home_type_frame,\n        text=\"Condo\",\n        command=self.house_type_validation,\n    )\n    self.house_type_mul_fam_switch = ctk.CTkSwitch(\n        self.home_type_frame,\n        text=\"Multi-Family\",\n        command=self.house_type_validation,\n    )\n\n    self.min_sqft_om = ctk.CTkOptionMenu(\n        self.square_feet_frame,\n        values=self.sqft_list,\n        command=lambda x: self.sqft_validation(),\n    )\n    self.max_sqft_om = ctk.CTkOptionMenu(\n        self.square_feet_frame,\n        values=self.sqft_list,\n        command=lambda x: self.sqft_validation(),\n    )\n    self.status_coming_soon_chb = ctk.CTkCheckBox(\n        self.status_frame, text=\"Coming soon\"\n    )\n    self.status_active_chb = ctk.CTkCheckBox(self.status_frame, text=\"Active\")\n    self.status_pending_chb = ctk.CTkCheckBox(\n        self.status_frame, text=\"Under contract/Pending\"\n    )  # missing one i think\n    self.sold_within_om = ctk.CTkOptionMenu(\n        self.sold_within_frame, values=self.sold_within_list\n    )\n\n    self.min_price_om = ctk.CTkOptionMenu(\n        self.price_range_frame,\n        values=self.price_list,\n        command=lambda x: self.price_validation(),\n    )\n    self.max_price_om = ctk.CTkOptionMenu(\n        self.price_range_frame,\n        values=self.price_list,\n        command=lambda x: self.price_validation(),\n    )\n\n    self.reset_filters_button = ctk.CTkButton(\n        self.reset_apply_frame,\n        text=\"Reset Filters\",\n        command=self.set_default_values,\n    )\n    self.apply_filters_button = ctk.CTkButton(\n        self.reset_apply_frame,\n        text=\"Apply Filters\",\n        command=self.change_to_search_page,\n    )\n\n    # Placing the widgets\n    self.for_sale_sold_label.grid(row=0, column=0)\n    self.stories_label.grid(row=0, column=0)\n    self.year_built_label.grid(row=0, column=0)\n    self.home_type_label.grid(row=0, column=0)\n    self.sqft_label.grid(row=0, column=0)\n    self.sale_status_label.grid(row=0, column=0)\n    self.price_range_label.grid(row=0, column=0)\n    self.year_built_from_label.grid(row=1, column=0)\n    self.year_built_to_label.grid(row=1, column=2)\n    self.price_range_from_label.grid(row=1, column=0)\n    self.price_range_to_label.grid(row=1, column=2)\n    self.sold_within_label.grid(row=0, column=0)\n    self.sold_within_from_label.grid(row=1, column=0)\n    self.sold_within_to_label.grid(row=1, column=2)\n\n    self.for_sale_sold_om.grid(row=0, column=1)\n    self.min_stories_om.grid(row=0, column=1)\n    self.min_year_built_om.grid(row=1, column=1)\n    self.max_year_built_om.grid(row=1, column=3)\n    self.min_sqft_om.grid(row=1, column=1)\n    self.max_sqft_om.grid(row=1, column=3)\n    self.sold_within_om.grid(row=0, column=1)\n    self.min_price_om.grid(row=1, column=1)\n    self.max_price_om.grid(row=1, column=3)\n    self.house_type_house_switch.grid(row=1, column=0)\n    self.house_type_townhouse_switch.grid(row=1, column=1)\n    self.house_type_condo_switch.grid(row=2, column=0)\n    self.house_type_mul_fam_switch.grid(row=2, column=1)\n    self.status_coming_soon_chb.grid(row=1, column=0)\n    self.status_active_chb.grid(row=1, column=1)\n    self.status_pending_chb.grid(row=1, column=2)\n    self.reset_filters_button.grid(row=0, column=0, sticky=\"nesw\")\n    self.apply_filters_button.grid(row=0, column=1, sticky=\"nesw\")\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.get_values","title":"<code>get_values()</code>","text":"<p>Get the values of all widgets on this page.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: dict of values</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def get_values(self) -&gt; dict[str, Any]:\n    \"\"\"Get the values of all widgets on this page.\n\n    Returns:\n        dict[str, Any]: dict of values\n    \"\"\"\n    match self.sold_within_om.get():\n        case \"Last 1 week\":\n            sold_within_days = RedfinApi.SoldWithinDays.ONE_WEEK\n        case \"Last 1 month\":\n            sold_within_days = RedfinApi.SoldWithinDays.ONE_MONTH\n        case \"Last 3 months\":\n            sold_within_days = RedfinApi.SoldWithinDays.THREE_MONTHS\n        case \"Last 6 months\":\n            sold_within_days = RedfinApi.SoldWithinDays.SIX_MONTHS\n        case \"Last 1 year\":\n            sold_within_days = RedfinApi.SoldWithinDays.ONE_YEAR\n        case \"Last 2 years\":\n            sold_within_days = RedfinApi.SoldWithinDays.TWO_YEARS\n        case \"Last 3 years\":\n            sold_within_days = RedfinApi.SoldWithinDays.THREE_YEARS\n        case _:\n            sold_within_days = RedfinApi.SoldWithinDays.FIVE_YEARS\n\n    return {\n        \"for sale sold\": self.for_sale_sold_om.get(),\n        \"min stories\": self.min_stories_om.get(),\n        \"max year built\": self.max_year_built_om.get(),  # do validation here\n        \"min year built\": self.min_year_built_om.get(),\n        \"sold within\": sold_within_days.value,\n        \"status active\": bool(self.status_active_chb.get()),\n        \"status coming soon\": bool(self.status_coming_soon_chb.get()),\n        \"status pending\": bool(self.status_pending_chb.get()),\n        \"house type house\": bool(self.house_type_house_switch.get()),\n        \"house type townhouse\": bool(self.house_type_townhouse_switch.get()),\n        \"house type mul fam\": bool(self.house_type_mul_fam_switch.get()),\n        \"house type condo\": bool(self.house_type_condo_switch.get()),\n        \"max sqft\": self.max_sqft_om.get(),\n        \"min sqft\": self.min_sqft_om.get(),\n        \"max price\": self.max_price_om.get(),\n        \"min price\": self.min_price_om.get(),\n    }\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.house_type_validation","title":"<code>house_type_validation()</code>","text":"<p>House type switch validation to make sure at lest house is selected.</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def house_type_validation(self) -&gt; None:\n    \"\"\"House type switch validation to make sure at lest house is selected.\"\"\"\n    if not any(\n        [\n            self.house_type_house_switch.get(),\n            self.house_type_condo_switch.get(),\n            self.house_type_mul_fam_switch.get(),\n            self.house_type_townhouse_switch.get(),\n        ]\n    ):\n        self.house_type_house_switch.select()\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.price_validation","title":"<code>price_validation()</code>","text":"<p>Called when price range min om gets changed</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def price_validation(self):\n    \"\"\"Called when price range min om gets changed\"\"\"\n    if (\n        self.max_price_om.get() == RedfinApi.Price.NONE.value\n        or self.min_price_om.get() == RedfinApi.Price.NONE.value\n    ):\n        return\n    if int(self.max_price_om.get()) &lt; int(self.min_price_om.get()):\n        self.max_price_om.set(self.min_price_om.get())\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.set_default_values","title":"<code>set_default_values()</code>","text":"<p>Set the default values for all widgets. Note:     Should be called after init and when clicking reset button.</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def set_default_values(self) -&gt; None:\n    \"\"\"Set the default values for all widgets.\n    Note:\n        Should be called after init and when clicking reset button.\n    \"\"\"\n    self.for_sale_sold_om.set(RedfinApi.SoldStatus.SOLD.value)\n    self.min_stories_om.set(RedfinApi.Stories.ONE.value)\n    self.min_year_built_om.set(str(self.cur_year - 1))\n    self.max_year_built_om.set(str(self.cur_year - 1))\n    self.sold_within_om.set(self.sold_within_list[-1])\n    self.max_price_om.set(RedfinApi.Price.NONE.value)\n    self.min_price_om.set(RedfinApi.Price.NONE.value)\n    self.max_sqft_om.set(RedfinApi.Sqft.NONE.value)\n    self.min_sqft_om.set(RedfinApi.Sqft.NONE.value)\n    self.status_active_chb.deselect()\n    self.status_pending_chb.deselect()\n    self.status_coming_soon_chb.deselect()\n    self.house_type_house_switch.select()\n    self.house_type_condo_switch.deselect()\n    self.house_type_townhouse_switch.deselect()\n    self.house_type_mul_fam_switch.deselect()\n    self.status_within_activate_deactivate(self.for_sale_sold_om.get())\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.sqft_validation","title":"<code>sqft_validation()</code>","text":"<p>Sqft dropdown callback</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def sqft_validation(self) -&gt; None:\n    \"\"\"Sqft dropdown callback\"\"\"\n    if (\n        self.max_sqft_om.get() == RedfinApi.Sqft.NONE.value\n        or self.min_sqft_om.get() == RedfinApi.Sqft.NONE.value\n    ):\n        return\n    if int(self.max_sqft_om.get()) &lt; int(self.min_sqft_om.get()):\n        self.max_sqft_om.set(self.min_sqft_om.get())\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.status_within_activate_deactivate","title":"<code>status_within_activate_deactivate(status)</code>","text":"<p>Deactivate or activate the status and sold within sections, since they depend on what type of sale a house is being searched with.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Event</code> <p>ignored</p> required Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def status_within_activate_deactivate(self, status) -&gt; None:\n    \"\"\"Deactivate or activate the status and sold within sections, since they depend on what type of sale a house is being searched with.\n\n    Args:\n        status (Event): ignored\n    \"\"\"\n    match self.for_sale_sold_om.get():\n        case RedfinApi.SoldStatus.FOR_SALE.value:\n            self.sale_status_label.configure(state=\"normal\")\n            self.status_active_chb.configure(state=\"normal\")\n            self.status_coming_soon_chb.configure(state=\"normal\")\n            self.status_pending_chb.configure(state=\"normal\")\n            self.sold_within_label.configure(state=\"disabled\")\n            self.sold_within_om.configure(state=\"disabled\")\n        case RedfinApi.SoldStatus.SOLD.value:\n            self.sale_status_label.configure(state=\"disabled\")\n            self.status_active_chb.configure(state=\"disabled\")\n            self.status_coming_soon_chb.configure(state=\"disabled\")\n            self.status_pending_chb.configure(state=\"disabled\")\n            self.sold_within_label.configure(state=\"normal\")\n            self.sold_within_om.configure(state=\"normal\")\n</code></pre>"},{"location":"gui/filterspage/#gui.filterspage.FiltersPage.year_validation","title":"<code>year_validation()</code>","text":"<p>Year drop down callback</p> Source code in <code>src\\gui\\filterspage.py</code> <pre><code>def year_validation(self) -&gt; None:\n    \"\"\"Year drop down callback\"\"\"\n    if int(self.max_year_built_om.get()) &lt; int(self.min_year_built_om.get()):\n        self.max_year_built_om.set(self.min_year_built_om.get())\n</code></pre>"},{"location":"gui/searchpage/","title":"Searchpage","text":""},{"location":"gui/searchpage/#gui.searchpage.SearchPage","title":"<code>SearchPage</code>","text":"<p>             Bases: <code>CTkFrame</code></p> Source code in <code>src\\gui\\searchpage.py</code> <pre><code>class SearchPage(ctk.CTkFrame):\n    def __init__(self, master: ctk.CTk, **kwargs):\n        super().__init__(master, **kwargs)\n        self.master = master\n        self.datapage = None\n        self.label_font = ctk.CTkFont(\"Roboto\", 34)\n        self.MATCHES_TO_DISPLAY = 20  # performance and practicality\n        self.auto_complete_series = get_unique_msa_from_master()\n        self.current_auto_complete_series = None\n        self.prev_search_bar_len = 0\n        self.filters_page = FiltersPage(self.master, self)\n        self.create_widgets()\n\n    def create_widgets(self) -&gt; None:\n        \"\"\"Create widgets.\"\"\"\n        self.top_text = ctk.CTkLabel(\n            self,\n            text=\"Residential Heating Search For Metropolitan Statistical Areas\",\n            font=self.label_font,\n            wraplength=600,\n        )\n        CTkToolTip(\n            self.top_text,\n            delay=0.25,\n            message=\"An MSA is a census defined region that consists of a city and \\nsurrounding communities that are linked by social and economic factors. \\nThe core city has a population of at least 50,000\",\n        )\n        self.redfin_filters_button = ctk.CTkButton(\n            self,\n            corner_radius=10,\n            height=35,\n            text=\"Add Filters\",\n            command=self.change_to_filters_page,\n        )\n        CTkToolTip(\n            self.redfin_filters_button,\n            delay=0.25,\n            message=\"Select filters for your search.\",\n        )\n        self.search_bar = ctk.CTkEntry(\n            self, height=40, corner_radius=40, placeholder_text=\"Search for an MSA\"\n        )\n        self.suggestion_list_box = CTkListbox(\n            self,\n            text_color=(\"gray10\", \"#DCE4EE\"),  # type: ignore\n            border_width=2,\n            command=lambda x: self.update_entry_on_autocomplete_select(x),\n        )\n        self.search_button = ctk.CTkButton(\n            self,\n            text=\"Search\",\n            fg_color=\"transparent\",\n            height=35,\n            corner_radius=10,\n            border_width=2,\n            text_color=(\"gray10\", \"#DCE4EE\"),\n            command=self.validate_entry_box_and_search,\n        )\n\n        self.columnconfigure((0, 2), weight=1)\n        self.columnconfigure(1, weight=4)\n        self.rowconfigure(0, weight=10)\n        self.rowconfigure(1, weight=4)\n        self.rowconfigure(2, weight=10)\n\n        self.top_text.grid(column=0, row=0, columnspan=3)\n\n        self.redfin_filters_button.grid(column=0, row=1, padx=(0, 40), sticky=\"e\")\n\n        self.search_bar.grid(column=1, row=1, sticky=\"ew\")\n\n        self.suggestion_list_box.grid(column=1, row=2, sticky=\"new\", pady=(10, 0))\n\n        self.search_button.grid(column=2, row=1, padx=(40, 0), sticky=\"w\")\n\n        self.suggestion_list_box.grid_remove()\n        self.search_bar.bind(\n            \"&lt;KeyRelease&gt;\", command=lambda x: self.update_suggestions_listbox(x)\n        )\n\n    def update_suggestions_listbox(self, x: Event | None) -&gt; None:\n        \"\"\"Update the suggestions box based on the contents of 'self.search_bar'.\n\n        Args:\n            x (Event | None): ignored\n        \"\"\"\n        cur_text = re.escape(self.search_bar.get())\n        if cur_text == \"\":\n            # only gets called when all text has been deleted\n            self.current_auto_complete_series = self.auto_complete_series\n            self.suggestion_list_box.grid_remove()\n        else:\n            self.suggestion_list_box.delete(\"all\")\n            if (\n                self.current_auto_complete_series is None\n                or len(cur_text) &lt; self.prev_search_bar_len\n            ):\n                self.current_auto_complete_series = self.auto_complete_series.filter(\n                    self.auto_complete_series.str.contains(rf\"(?i)^{cur_text}\")\n                )\n            else:\n                self.current_auto_complete_series = (\n                    self.current_auto_complete_series.filter(\n                        self.current_auto_complete_series.str.contains(\n                            rf\"(?i)^{cur_text}\"\n                        )\n                    )\n                )\n            self.suggestion_list_box.grid()\n            self.current_auto_complete_series.head(\n                self.MATCHES_TO_DISPLAY\n            ).map_elements(\n                lambda msa: self.suggestion_list_box.insert(\n                    \"end\", msa, border_width=2, border_color=\"gray\"\n                ),\n                return_dtype=pl.Utf8,\n            )\n        self.prev_search_bar_len = len(cur_text)\n\n    def update_entry_on_autocomplete_select(self, x: Event) -&gt; None:\n        \"\"\"Suggestions list box callback for when a button in the list box is selected.\"\"\"\n        self.search_bar.delete(0, ctk.END)\n        self.search_bar.insert(0, x)\n        self.update_suggestions_listbox(None)\n\n    def validate_entry_box_and_search(self) -&gt; None:\n        \"\"\"Validate `self.search_bar` contents and search if the contents are an MSA name.\"\"\"\n        cur_text = self.search_bar.get()\n        if len(cur_text) == 0:\n            cur_text = r\"!^\"\n        if any(self.auto_complete_series.str.contains(rf\"{cur_text}$\")):\n            self.data_page = DataPage(self.master)\n            self.data_page.grid(row=0, column=0, sticky=\"news\")\n            self.go_to_data_page(cur_text)\n            self.search_metros_threaded(cur_text)\n        else:\n            CTkMessagebox(\n                self,\n                title=\"Error\",\n                message=\"Inputted name is not in MSA name list!\",\n                icon=\"warning\",\n            )\n\n    def go_to_data_page(self, msa_name: str) -&gt; None:\n        \"\"\"Switch to data page.\n\n        Args:\n            msa_name (str): Metropolitan Statistical Area name\n        \"\"\"\n        if self.data_page is not None:\n            self.grid_remove()\n            self.data_page.grid()\n            self.data_page.set_msa_name(msa_name)\n\n    def search_metros_threaded(self, msa_name: str) -&gt; None:\n        \"\"\"Search the given Metropolitan Statistical Area name for housing attributes.\n\n        Args:\n            msa_name (str): Metropolitan Statistical Area name\n        \"\"\"\n        redfin_searcher = RedfinApi()\n        lock = threading.Lock()\n        with lock:\n            threading.Thread(\n                target=redfin_searcher.get_house_attributes_from_metro,\n                args=(msa_name, self.filters_page.get_values()),\n                daemon=True,\n            ).start()\n\n    def change_to_filters_page(self) -&gt; None:\n        \"\"\"Change to filters page.\"\"\"\n        if self.filters_page is not None:\n            self.filters_page.grid(row=0, column=0, sticky=\"news\")\n            self.grid_remove()\n            self.filters_page.grid()\n</code></pre>"},{"location":"gui/searchpage/#gui.searchpage.SearchPage.change_to_filters_page","title":"<code>change_to_filters_page()</code>","text":"<p>Change to filters page.</p> Source code in <code>src\\gui\\searchpage.py</code> <pre><code>def change_to_filters_page(self) -&gt; None:\n    \"\"\"Change to filters page.\"\"\"\n    if self.filters_page is not None:\n        self.filters_page.grid(row=0, column=0, sticky=\"news\")\n        self.grid_remove()\n        self.filters_page.grid()\n</code></pre>"},{"location":"gui/searchpage/#gui.searchpage.SearchPage.create_widgets","title":"<code>create_widgets()</code>","text":"<p>Create widgets.</p> Source code in <code>src\\gui\\searchpage.py</code> <pre><code>def create_widgets(self) -&gt; None:\n    \"\"\"Create widgets.\"\"\"\n    self.top_text = ctk.CTkLabel(\n        self,\n        text=\"Residential Heating Search For Metropolitan Statistical Areas\",\n        font=self.label_font,\n        wraplength=600,\n    )\n    CTkToolTip(\n        self.top_text,\n        delay=0.25,\n        message=\"An MSA is a census defined region that consists of a city and \\nsurrounding communities that are linked by social and economic factors. \\nThe core city has a population of at least 50,000\",\n    )\n    self.redfin_filters_button = ctk.CTkButton(\n        self,\n        corner_radius=10,\n        height=35,\n        text=\"Add Filters\",\n        command=self.change_to_filters_page,\n    )\n    CTkToolTip(\n        self.redfin_filters_button,\n        delay=0.25,\n        message=\"Select filters for your search.\",\n    )\n    self.search_bar = ctk.CTkEntry(\n        self, height=40, corner_radius=40, placeholder_text=\"Search for an MSA\"\n    )\n    self.suggestion_list_box = CTkListbox(\n        self,\n        text_color=(\"gray10\", \"#DCE4EE\"),  # type: ignore\n        border_width=2,\n        command=lambda x: self.update_entry_on_autocomplete_select(x),\n    )\n    self.search_button = ctk.CTkButton(\n        self,\n        text=\"Search\",\n        fg_color=\"transparent\",\n        height=35,\n        corner_radius=10,\n        border_width=2,\n        text_color=(\"gray10\", \"#DCE4EE\"),\n        command=self.validate_entry_box_and_search,\n    )\n\n    self.columnconfigure((0, 2), weight=1)\n    self.columnconfigure(1, weight=4)\n    self.rowconfigure(0, weight=10)\n    self.rowconfigure(1, weight=4)\n    self.rowconfigure(2, weight=10)\n\n    self.top_text.grid(column=0, row=0, columnspan=3)\n\n    self.redfin_filters_button.grid(column=0, row=1, padx=(0, 40), sticky=\"e\")\n\n    self.search_bar.grid(column=1, row=1, sticky=\"ew\")\n\n    self.suggestion_list_box.grid(column=1, row=2, sticky=\"new\", pady=(10, 0))\n\n    self.search_button.grid(column=2, row=1, padx=(40, 0), sticky=\"w\")\n\n    self.suggestion_list_box.grid_remove()\n    self.search_bar.bind(\n        \"&lt;KeyRelease&gt;\", command=lambda x: self.update_suggestions_listbox(x)\n    )\n</code></pre>"},{"location":"gui/searchpage/#gui.searchpage.SearchPage.go_to_data_page","title":"<code>go_to_data_page(msa_name)</code>","text":"<p>Switch to data page.</p> <p>Parameters:</p> Name Type Description Default <code>msa_name</code> <code>str</code> <p>Metropolitan Statistical Area name</p> required Source code in <code>src\\gui\\searchpage.py</code> <pre><code>def go_to_data_page(self, msa_name: str) -&gt; None:\n    \"\"\"Switch to data page.\n\n    Args:\n        msa_name (str): Metropolitan Statistical Area name\n    \"\"\"\n    if self.data_page is not None:\n        self.grid_remove()\n        self.data_page.grid()\n        self.data_page.set_msa_name(msa_name)\n</code></pre>"},{"location":"gui/searchpage/#gui.searchpage.SearchPage.search_metros_threaded","title":"<code>search_metros_threaded(msa_name)</code>","text":"<p>Search the given Metropolitan Statistical Area name for housing attributes.</p> <p>Parameters:</p> Name Type Description Default <code>msa_name</code> <code>str</code> <p>Metropolitan Statistical Area name</p> required Source code in <code>src\\gui\\searchpage.py</code> <pre><code>def search_metros_threaded(self, msa_name: str) -&gt; None:\n    \"\"\"Search the given Metropolitan Statistical Area name for housing attributes.\n\n    Args:\n        msa_name (str): Metropolitan Statistical Area name\n    \"\"\"\n    redfin_searcher = RedfinApi()\n    lock = threading.Lock()\n    with lock:\n        threading.Thread(\n            target=redfin_searcher.get_house_attributes_from_metro,\n            args=(msa_name, self.filters_page.get_values()),\n            daemon=True,\n        ).start()\n</code></pre>"},{"location":"gui/searchpage/#gui.searchpage.SearchPage.update_entry_on_autocomplete_select","title":"<code>update_entry_on_autocomplete_select(x)</code>","text":"<p>Suggestions list box callback for when a button in the list box is selected.</p> Source code in <code>src\\gui\\searchpage.py</code> <pre><code>def update_entry_on_autocomplete_select(self, x: Event) -&gt; None:\n    \"\"\"Suggestions list box callback for when a button in the list box is selected.\"\"\"\n    self.search_bar.delete(0, ctk.END)\n    self.search_bar.insert(0, x)\n    self.update_suggestions_listbox(None)\n</code></pre>"},{"location":"gui/searchpage/#gui.searchpage.SearchPage.update_suggestions_listbox","title":"<code>update_suggestions_listbox(x)</code>","text":"<p>Update the suggestions box based on the contents of 'self.search_bar'.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Event | None</code> <p>ignored</p> required Source code in <code>src\\gui\\searchpage.py</code> <pre><code>def update_suggestions_listbox(self, x: Event | None) -&gt; None:\n    \"\"\"Update the suggestions box based on the contents of 'self.search_bar'.\n\n    Args:\n        x (Event | None): ignored\n    \"\"\"\n    cur_text = re.escape(self.search_bar.get())\n    if cur_text == \"\":\n        # only gets called when all text has been deleted\n        self.current_auto_complete_series = self.auto_complete_series\n        self.suggestion_list_box.grid_remove()\n    else:\n        self.suggestion_list_box.delete(\"all\")\n        if (\n            self.current_auto_complete_series is None\n            or len(cur_text) &lt; self.prev_search_bar_len\n        ):\n            self.current_auto_complete_series = self.auto_complete_series.filter(\n                self.auto_complete_series.str.contains(rf\"(?i)^{cur_text}\")\n            )\n        else:\n            self.current_auto_complete_series = (\n                self.current_auto_complete_series.filter(\n                    self.current_auto_complete_series.str.contains(\n                        rf\"(?i)^{cur_text}\"\n                    )\n                )\n            )\n        self.suggestion_list_box.grid()\n        self.current_auto_complete_series.head(\n            self.MATCHES_TO_DISPLAY\n        ).map_elements(\n            lambda msa: self.suggestion_list_box.insert(\n                \"end\", msa, border_width=2, border_color=\"gray\"\n            ),\n            return_dtype=pl.Utf8,\n        )\n    self.prev_search_bar_len = len(cur_text)\n</code></pre>"},{"location":"gui/searchpage/#gui.searchpage.SearchPage.validate_entry_box_and_search","title":"<code>validate_entry_box_and_search()</code>","text":"<p>Validate <code>self.search_bar</code> contents and search if the contents are an MSA name.</p> Source code in <code>src\\gui\\searchpage.py</code> <pre><code>def validate_entry_box_and_search(self) -&gt; None:\n    \"\"\"Validate `self.search_bar` contents and search if the contents are an MSA name.\"\"\"\n    cur_text = self.search_bar.get()\n    if len(cur_text) == 0:\n        cur_text = r\"!^\"\n    if any(self.auto_complete_series.str.contains(rf\"{cur_text}$\")):\n        self.data_page = DataPage(self.master)\n        self.data_page.grid(row=0, column=0, sticky=\"news\")\n        self.go_to_data_page(cur_text)\n        self.search_metros_threaded(cur_text)\n    else:\n        CTkMessagebox(\n            self,\n            title=\"Error\",\n            message=\"Inputted name is not in MSA name list!\",\n            icon=\"warning\",\n        )\n</code></pre>"}]}